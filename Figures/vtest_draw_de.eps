%!PS-Adobe-2.0 EPSF-2.0
%%Title: vtest_draw_de.draw  Ð  /clients/fukuda/Paper/GeomtricComp
%%Creator: Draw
%%CreationDate: Fri Nov 21 15:58:41 1997
%%For: fukuda
%%DocumentFonts: (atend)
%%Pages: 0 0
%%BoundingBox: 94 405 399 712
%%NXNextStepVersion: 3.0
%%EndComments

%%BeginProcSet: /usr/lib/NextStep/printPackage.ps 3.0
%!
% NeXT Printing Package
% Version: 3.1J
% Modified by Canon based on Version 3.0 : July 6,1992
% Copyright: 1988, NeXT, Inc.

/__NXdef{1 index where{pop pop pop}{def}ifelse}bind def
/__NXbdef{1 index where{pop pop pop}{bind def}ifelse}bind def
/UserObjects 10 array __NXdef
/defineuserobject{
	exch dup 1 add dup UserObjects length gt{
		array dup 0 UserObjects putinterval
		/UserObjects exch def
	}{pop}ifelse UserObjects exch 3 -1 roll put
}__NXbdef
/undefineuserobject{UserObjects exch null put}__NXbdef
/execuserobject{UserObjects exch get exec}__NXbdef
/__NXRectPath{4 2 roll moveto 1 index 0 rlineto
0 exch rlineto neg 0 rlineto closepath}__NXbdef
/__NXProcessRectArgs{
	1 index type /arraytype eq{
		exch 0 4 2 index length 1 sub{
			dup 3 add 1 exch{1 index exch get exch}for
			5 1 roll 5 index exec
		}for pop pop
	}{exec}ifelse
}__NXbdef
/rectfill{gsave newpath {__NXRectPath fill} __NXProcessRectArgs grestore}__NXbdef
/rectclip{newpath {__NXRectPath} __NXProcessRectArgs clip newpath}__NXbdef
/rectstroke{
	gsave newpath dup type /arraytype eq{dup length 6 eq}{false}ifelse{
		{gsave __NXRectPath null concat stroke grestore}
		dup length array cvx copy dup 2 4 -1 roll put __NXProcessRectArgs
	}{{__NXRectPath stroke} __NXProcessRectArgs}ifelse grestore
}__NXbdef
/_NXLevel2 systemdict /languagelevel known {languagelevel 2 ge}{false}ifelse __NXdef
systemdict /cshow known {
/xyshow {
    {
	pop pop currentpoint 3 index 1 get add exch 3 index 0 get add exch
	4 -1 roll dup length 2 sub 2 exch getinterval 4 1 roll
	( ) dup 0 6 -1 roll put show moveto
    } 3 -1 roll cshow
    pop
}__NXbdef
/xshow {
    {
	pop pop currentpoint exch 3 index 0 get add exch
	4 -1 roll dup length 1 sub 1 exch getinterval 4 1 roll
	( ) dup 0 6 -1 roll put show moveto
    } 3 -1 roll cshow
    pop
}__NXbdef
/yshow{
    {
	pop pop currentpoint 3 index 0 get add
	4 -1 roll dup length 1 sub 1 exch getinterval 4 1 roll
	( ) dup 0 6 -1 roll put show moveto
    } 3 -1 roll cshow
    pop
}__NXbdef
}{
/xyshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index 2 mul 1 add get add exch
		3 index	3 index 2 mul get add exch moveto pop
	}for pop pop
}__NXbdef
/xshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		exch 3 index 3 index get add exch moveto pop
	}for pop pop
}__NXbdef
/yshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index get add moveto pop
	}for pop pop
}__NXbdef
} ifelse
/arct{arcto pop pop pop pop}__NXbdef
/setbbox{pop pop pop pop}__NXbdef
/ucache{}__NXbdef
/ucachestatus{mark 0 0 0 0 0}__NXbdef
/setucacheparams{cleartomark}__NXbdef
/uappend{systemdict begin cvx exec end}__NXbdef
/ueofill{gsave newpath uappend eofill grestore}__NXbdef
/ufill{gsave newpath uappend fill grestore}__NXbdef
/ustroke{
	gsave newpath dup length 6 eq
	{exch uappend concat}{uappend}ifelse
	stroke grestore
}__NXbdef
/__NXustrokepathMatrix dup where {pop pop}{matrix def}ifelse
/ustrokepath{
	newpath dup length 6 eq{
		exch uappend __NXustrokepathMatrix currentmatrix exch concat
		strokepath setmatrix
	}{uappend strokepath}ifelse
} __NXbdef
/upath{
	[exch {/ucache cvx}if pathbbox /setbbox cvx
	 {/moveto cvx}{/lineto cvx}{/curveto cvx}{/closepath cvx}pathforall]cvx
} __NXbdef
/setstrokeadjust{pop}__NXbdef
/currentstrokeadjust{false}__NXbdef
/selectfont{exch findfont exch
dup type /arraytype eq {makefont}{scalefont}ifelse setfont}__NXbdef
/_NXCombineArrays{
	counttomark dup 2 add index dup length 3 -1 roll {
		2 index length sub dup 4 1 roll 1 index exch 4 -1 roll putinterval exch
	}repeat pop pop pop
}__NXbdef
/flushgraphics{}def
/setwindowtype{pop pop}def
/currentwindowtype{pop 0}def
/setalpha{pop}def
/currentalpha{1.0}def
/hidecursor{}def
/obscurecursor{}def
/revealcursor{}def
/setcursor{4 {pop}repeat}bind def
/showcursor{}def

/SharedFontDirectory FontDirectory __NXdef
/_JPN /GothicBBB-Medium.Hankaku dup findfont /FontName get eq def
/_@Private dup where {pop pop}{50 dict def}ifelse
/__NJdef _JPN {{//_@Private 3 1 roll put}}{{pop pop}} ifelse bind def
/__NJbdef _JPN {{//_@Private 2 index known {pop pop}{bind //_@Private 3 1 roll put}ifelse}}{{pop pop}} ifelse bind def
/_str 128 string __NJdef
/_find { % /FName _find FontOrFName bool
    false 0 {dup 3 index known {3 -1 roll get exch pop true exit}{pop}ifelse} forall
} bind dup 1
[/SharedFontDirectory dup where {exch get}{pop}ifelse //FontDirectory] put //_@Private 3 1 roll put
/_copyfont@ { % -font- extension _copyfont@ -dict-
    1 index maxlength add dict begin {
	1 index /FID ne 2 index /UniqueID ne and {def}{pop pop}ifelse
    } forall currentdict end
} __NJbdef
/_bind { % /n1 /n2 _bind /n1+2
    exch dup length 2 index length add _str 4 2 roll
    _str cvs length exch dup length string cvs putinterval
    _str exch 0 exch getinterval cvn
} __NJbdef
/NDEncoding 256 array dup 0 1 255 {/.notdef put dup} for pop __NJdef
/_shiftE { % /Fname start length target -font- _shiftE -dict-
    0 _copyfont@ begin Encoding 4 2 roll getinterval NDEncoding 256 array
    copy dup 4 -2 roll putinterval Encoding length 256 eq {
    dup dup 0 128 getinterval 128 exch putinterval } if
    /Encoding exch def /FontName exch def currentdict end
} __NJbdef
/_makeSGFDV { % - _makeSGFDV [FDV]
    [ _FN /.WP-Symbol _bind dup findfont dup /FontName get 3 -1 roll ne {
      pop /_FN /GothicBBB-Medium __NJdef /GothicBBB-Medium.WP-Symbol findfont
    } if
    _SGFN /.rFC _bind dup 0 96 32 5 index _shiftE definefont
    _SGFN /.rFD _bind dup 96 32 32 6 index _shiftE definefont
    _SGFN /.rFE _bind dup 0 128 0 _FN /-Ext-H _bind findfont dup /Encoding get
    16#2d get exch /FDepVector get exch get _shiftE dup /Encoding 2 copy get
    [16#f0 16#f1 16#f2 16#f5 16#f6 16#f7 16#fa 16#fb 16#fc] {
	dup 2 index exch /.notdef put 128 sub 1 index exch /.notdef put
    } forall put definefont
    ] dup 0 /NotDefFont findfont put
} __NJbdef
/_defSGaiji { % /fullname /basename _defSGaiji -sysGaiji-
    /_FN exch __NJdef /_SGFN exch __NJdef 15 dict
    dup /FontName _SGFN put	dup /FontType 0 put
    dup /FMapType 2 put		dup /FontMatrix matrix put
    dup /FontBBox {0 -140 1000 880} put
    dup /Encoding 256 array 0 1 255 {1 index exch 0 put}for
	dup 16#FC 1 put    dup 16#FD 2 put    dup 16#FE 3 put put
    dup /FDepVector _makeSGFDV put    dup /isNeXTGaiji true put
    _SGFN exch definefont
} __NJbdef
/_defNeXTF { % /fullname /basename Hflag _defNeXTF
    /_FN 2 index __NJdef /_HF exch __NJdef _HF {/-EUC-H}{/-EUC-V}ifelse
    _bind dup findfont dup /FontName get 3 -1 roll ne {
      pop _HF {/GothicBBB-Medium-EUC-H}{/GothicBBB-Medium-EUC-V}ifelse findfont
    } if
    1 _copyfont@ begin
    /FontName 1 index def
    /UserGaijiName _FN /-NeXT-UserGaiji _bind def
    /Encoding Encoding dup length array copy FMapType 2 eq {dup 16#8E 78 put
	0 1 9 {dup 16#F5 add exch 79 add 2 index 3 1 roll put} for
    }{  dup 16#11D 78 put
	0 1 9 {dup dup add 16#1EB add exch 79 add 2 index 3 1 roll put} for
    } ifelse def
    /FDepVector [FDepVector aload pop _FN /.Hankaku _bind
	dup /_ _bind exch 128 128 0 3 index findfont _shiftE definefont
	UserGaijiName findfont dup /isNeXTGaiji 2 copy known {
	    get {/FDepVector get 1 7 getinterval aload pop
	    }{pop /NotDefFont findfont 6 {dup} repeat}ifelse
	}{pop pop pop /NotDefFont findfont 6 {dup} repeat}ifelse
	_FN /-NeXT-SystemGaiji _bind findfont /FDepVector get 1 3 getinterval
	aload pop] def
    currentdict end definefont
} __NJbdef
/_findNarrow { % /FName _findNarrow -font-
    dup _str cvs (Narrow) anchorsearch {pop cvn exch _find {exch pop}{
	exch findfont 0 _copyfont@ dup /FontName 3 index put
	dup /FontMatrix 2 copy get [5 6 div 0 0 1 0 0] matrix concatmatrix put
	definefont}ifelse
    }{pop findfont}ifelse
} __NJbdef
/_defNXR { % /NXname /rname _defNXR -font-
    findfont 0 _copyfont@
    dup /FontName 3 index put
    dup /Encoding NextStepEncoding put definefont
} bind def
/_defmixfont@ { % /FName [/ASCII /KANJI shiftmtx] _defmixfont@ -font-
    aload pop /_@shiftmatrix exch __NJdef (-NeXT-H) _bind findfont
    /_EUC exch __NJdef _findNarrow /_@ASCII exch __NJdef
    dup /_ exch _bind dup _EUC /Encoding get length 2 idiv dup 0 _EUC _shiftE
    dup /Encoding 2 copy get dup
	3 index /FMapType get 5 eq {16#41}{16#20}ifelse 89 put  put
    dup /FontMatrix _@shiftmatrix put
    dup /FDepVector [ _EUC /FDepVector get aload pop _EUC /FMapType get 5 eq {
	/_S_ _@ASCII /FontName get _bind _@ASCII 0 _copyfont@
	dup /Encoding 2 copy get 256 array copy dup dup dup 0 128 getinterval
	128 exch putinterval 0 _@ASCII /Encoding get 128 128 getinterval
	putinterval put dup /FontName 3 index put definefont
	}{_@ASCII}ifelse
	 _@shiftmatrix matrix invertmatrix makefont] put definefont
    15 dict begin
	/FontName 2 index def
	/FontType 0 def     /PaintType 0 def
	/FMapType 4 def     /FontMatrix matrix def
	/Encoding [0 1] def /PrefEnc 1 index /Encoding get def
	/FontBBox _@ASCII /FontBBox get 4 array copy cvx
	    dup 2 get 1000 lt {dup 2 1000 put}if
	    dup 3 get 880 lt {dup 3 880 put}if def
	/FontInfo _@ASCII /FontInfo get def
	/FDepVector [_@ASCII 4 -1 roll] def
	currentdict end definefont
} __NJbdef
/FixedRyuminCourier-Light {
	[/NarrowCourier /Ryumin-Light matrix] _defmixfont@} __NJbdef
/FixedRyuminCourier-LightOblique {
	[/NarrowCourier-Oblique /Ryumin-Light [1 0 .212557 1 0 0]] _defmixfont@} __NJbdef
/FixedRyuminCourier-Bold {
	[/NarrowCourier-Bold /Ryumin-Light matrix] _defmixfont@} __NJbdef
/FixedRyuminCourier-BoldOblique {
	[/NarrowCourier-BoldOblique /Ryumin-Light [1 0 .212557 1 0 0]] _defmixfont@} __NJbdef
/RyuminTimes-Light {
	[/Times-Roman /Ryumin-Light matrix] _defmixfont@} __NJbdef
/RyuminTimes-LightOblique {
	[/Times-Italic /Ryumin-Light [1 0 .277325 1 0 0]] _defmixfont@} __NJbdef
/RyuminTimes-Bold {
	[/Times-Bold /Ryumin-Light matrix] _defmixfont@} __NJbdef
/RyuminTimes-BoldOblique {
	[/Times-BoldItalic /Ryumin-Light [1 0 .277325 1 0 0]] _defmixfont@} __NJbdef
/FixedGothicBBBCourier {
	[/NarrowCourier /GothicBBB-Medium matrix] _defmixfont@} __NJbdef
/FixedGothicBBBCourier-Oblique {
	[/NarrowCourier-Oblique /GothicBBB-Medium [1 0 .212557 1 0 0]] _defmixfont@} __NJbdef
/FixedGothicBBBCourier-Bold {
	[/NarrowCourier-Bold /GothicBBB-Medium matrix] _defmixfont@} __NJbdef
/FixedGothicBBBCourier-BoldOblique {
	[/NarrowCourier-BoldOblique /GothicBBB-Medium [1 0 .212557 1 0 0]] _defmixfont@} __NJbdef
/GothicBBBHelvetica {
	[/Helvetica /GothicBBB-Medium matrix] _defmixfont@} __NJbdef
/GothicBBBHelvetica-Oblique {
	[/Helvetica-Oblique /GothicBBB-Medium [1 0 .212557 1 0 0]] _defmixfont@} __NJbdef
/GothicBBBHelvetica-Bold {
	[/Helvetica-Bold /GothicBBB-Medium matrix] _defmixfont@} __NJbdef
/GothicBBBHelvetica-BoldOblique {
	[/Helvetica-BoldOblique /GothicBBB-Medium [1 0 .212557 1 0 0]] _defmixfont@} __NJbdef
/TitleGothicBBBHelvetica {
	[/Helvetica /GothicBBB-Medium matrix] _defmixfont@} __NJbdef
/TitleGothicBBBHelvetica-Bold {
	[/Helvetica-Bold /GothicBBB-Medium matrix] _defmixfont@} __NJbdef

/NextStepEncoding where not{
/NextStepEncoding StandardEncoding 256 array copy def
0 [129/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/Ccedilla/Egrave
/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/Ugrave/Uacute
/Ucircumflex/Udieresis/Yacute/Thorn/mu/multiply/divide/copyright
176/registered 181/brokenbar 190/logicalnot 192/onesuperior 201/twosuperior
204/threesuperior 209/plusminus/onequarter/onehalf/threequarters/agrave
/aacute/acircumflex/atilde/adieresis/aring/ccedilla/egrave/eacute
/ecircumflex/edieresis/igrave 226/iacute 228/icircumflex/idieresis/eth
/ntilde 236/ograve/oacute/ocircumflex/otilde/odieresis 242/ugrave/uacute
/ucircumflex 246/udieresis/yacute 252/thorn/ydieresis]
{dup type /nametype eq
 {NextStepEncoding 2 index 2 index put pop 1 add}{exch pop}ifelse
}forall pop
/NextStepEncoding NextStepEncoding readonly def
/_NXfstr 128 string dup 0 (_NX) putinterval def
/_NXfindfont /findfont load def
/findfont{
 % Because we can never let NextStepEncoding get into
 % SharedFontDirectory, we cannot reencode a font to NextStepEncoding
 % if we are in shared mode.  So if currentshared is true,
 % we call the normal findfont and return that
 _JPN {//_@Private begin
    dup _str cvs (-NeXT-) search {
      cvn exch pop exch cvn dup /H eq {
	pop exch _find {exch pop}{exch true _defNeXTF}ifelse false
      }{
	dup /V eq {
	  pop exch _find {exch pop}{exch false _defNeXTF}ifelse false
	}{
	  /SystemGaiji eq {
	    exch _find {exch pop}{exch _defSGaiji}ifelse false
	  }{pop true} ifelse
	} ifelse
      } ifelse
    }{
      (NX@) anchorsearch {
        pop exch _find {exch pop}{exch cvn _defNXR}ifelse false
      }{pop true} ifelse
    } ifelse
    {
      dup //_@Private exch known {dup load exec false}{true}ifelse
    }{false}ifelse
    end
 }{true}ifelse {
 /currentshared where {pop currentshared} {false} ifelse
 {_NXfindfont}
 {dup _NXfstr 3 125 getinterval cvs length 3 add _NXfstr 0 3 -1 roll
  getinterval cvn exch FontDirectory 2 index known 
  {pop FontDirectory exch get}
  {_NXfindfont dup /Encoding get StandardEncoding eq
   {	dup length dict exch
	{1 index /FID ne {2 index 3 1 roll put}{pop pop}ifelse}forall
	 dup /Encoding NextStepEncoding put definefont
	}{exch pop} ifelse
   }ifelse
 }ifelse
 } if
}bind def
}{pop}ifelse
/_NXImageString {/__NXImageString where{pop}{/__NXImageString 4000 string __NXdef}ifelse __NXImageString}__NXbdef
/_NXDoImageOp{
	3 dict begin /parr 5 array def 1 index{dup}{1}ifelse /chans exch def
	chans 2 add 2 roll parr 0 chans getinterval astore pop
	5 index 4 index mul 2 index{1 sub 8 idiv 1 add mul}{mul 1 sub 8 idiv 1 add}ifelse
	4 index mul /totbytes exch def pop exch pop
	gsave matrix invertmatrix concat 0.5 setgray 0 0 4 2 roll rectfill grestore
	{0 1 chans 1 sub{parr exch get exec length totbytes exch sub /totbytes exch def}for totbytes 0 le{exit}if}loop end
}__NXbdef
/alphaimage{1 add _NXDoImageOp}def
_NXLevel2{ 
	/NXCalibratedRGBColorSpace where{pop}{
		/NXCalibratedRGBColorSpace
		{mark /NXCalibratedRGB /ColorSpace findresource exch pop}stopped
		{cleartomark /NXCalibratedRGB[/CIEBasedABC 2 dict dup begin 
		/MatrixLMN[.4124 .2126 .0193 .3576 .7152 .1192 .1805 .0722 .9505]def
		/WhitePoint[.9505 1 1.089] def end] /ColorSpace defineresource}if def}ifelse
	/nxsetrgbcolor{NXCalibratedRGBColorSpace setcolorspace setcolor}__NXbdef
	/nxsetgray{dup dup nxsetrgbcolor}__NXbdef
	/_NXCalibratedImage{exch{array astore dup length true}{false}ifelse
		8 -1 roll{NXCalibratedRGBColorSpace setcolorspace}if
		8 dict dup 9 1 roll begin /ImageType 1 def /MultipleDataSources exch def
		currentcolorspace 0 get /Indexed eq{pop /Decode[0 2 6 index exp 1 sub]def}
		{2 mul dup array /Decode exch def 1 sub 0 1 3 -1 roll{Decode exch dup 2 mod put}for}ifelse
		/DataSource exch def /ImageMatrix exch def 
		/BitsPerComponent exch def /Height exch def /Width exch def end image}__NXbdef
} {
	/setcmykcolor{
		1.0 exch sub dup dup 6 -1 roll sub dup 0 lt{pop 0}if 5 1 roll
		4 -1 roll sub dup 0 lt{pop 0}if 3 1 roll exch sub dup 0 lt{pop 0}if setrgbcolor}__NXbdef
	/currentcmykcolor{currentrgbcolor 3{1.0 exch sub 3 1 roll}repeat 0}__NXbdef
	/colorimage{2 copy 3 ne or{_NXDoImageOp}{4 index dup 8 ne exch 4 ne and{_NXDoImageOp}{
		pop pop save 6 1 roll 12 dict begin/Proc exch def/Res 0 string def
		/Alloc{2 index length mul 2 add dup 2 index load length gt{1.2 mul round cvi string def}{pop pop}ifelse}def
		1 index 8 eq{/Unpack{.34 Alloc}def}{
			/Wid 4 index 3 mul def exch pop 8 exch/Str1 0 string def/Lim Wid def
			/Unpack{.67 Alloc/Str1 2 Alloc 0 exch Lim exch
				{dup -4 bitshift 17 mul Str1 exch 4 index exch put 15 and 17 mul Str1 exch 3 index 1 add exch put
				2 sub dup 0 le{0 lt Wid exch{exch 1 sub exch}if}if exch 2 add exch
				}forall/Lim exch def Str1 exch 0 exch getinterval
			}def
		}ifelse
		/Ops[{.3 mul add 1}{.59 mul add 2}{.11 mul add round cvi Res exch 2 index exch put 1 add 0.0 0}]def/Val 0.0 def/Phase 0 def
		{0 Val Phase Proc/Res Unpack{exch Ops exch get exec}forall/Phase exch def/Val exch def Res exch 0 exch getinterval}
		image end restore}ifelse}ifelse
	}__NXbdef
	/nxsetrgbcolor{setrgbcolor}__NXbdef /nxsetgray{setgray}__NXbdef
	/setpattern{pop .5 setgray}__NXbdef
	/_NXCalibratedImage{dup 1 eq {pop pop image}{colorimage}ifelse pop}__NXbdef
} ifelse
/_NXSetCMYKOrRGB where{pop}{
	mark{systemdict /currentwindow get exec}stopped
	{{pop pop pop setcmykcolor}}{{nxsetrgbcolor pop pop pop pop}}ifelse /_NXSetCMYKOrRGB exch def cleartomark
}ifelse
%%EndProcSet

gsave
-20 -28 translate
 /__NXbasematrix matrix currentmatrix def
grestore
%%EndProlog
%%BeginSetup
/oval {
    translate scale newpath 0.5 0.5 0.5 0 360 arc closepath
} def /line {
    moveto rlineto stroke
} def /setup {
    setlinewidth setlinecap setlinejoin gsave
} def /arrow {
    newpath moveto dup rotate -13 6 rlineto 4 -6 rlineto -4 -6 rlineto closepath gsave 0 setlinejoin stroke grestore fill neg rotate
} def
%%EndSetup
gsave
94 405 305 307 rectclip
0 0 0 setup
106.000000 417.000000 transform
gsave __NXbasematrix setmatrix itransform translate
0 0 282 282 rectclip

/__NXEPSSave save def /showpage {} def
_NXLevel2{/_NXsethsb where{pop}{/_NXsethsb /sethsbcolor load def}ifelse /sethsbcolor{_NXsethsb currentrgbcolor nxsetrgbcolor}def /setrgbcolor{nxsetrgbcolor}bind def /setgray{nxsetgray}bind def
/_NXcimage where{pop}{/_NXcimage /colorimage load def}ifelse /colorimage{dup 3 eq{true 2 index{1 index}{1}ifelse 7 add 1 roll _NXCalibratedImage}{_NXcimage}ifelse}def}if
0 setgray 0 setlinecap 1 setlinewidth
0 setlinejoin 10 setmiterlimit [] 0 setdash newpath count /__NXEPSOpCount exch def /__NXEPSDictCount countdictstack def
%%BeginDocument: 
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 282 282
%%Creator: NeXT Mathematica Notebook Front End Version 2.2
%%Title: Clipboard
%%CreationDate: Sometime Sometime
%%EndComments
/Mnodistort true def
150 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
		Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {	% str Mbbox xlow ylow xhigh yhigh
	1 dict begin
	0 0 moveto		% str
	/temp (T) def
	{	gsave
		currentpoint newpath moveto
		temp 0 3 -1 roll put temp
		false charpath flattenpath currentpoint
		pathbbox
		grestore moveto lineto moveto} forall
	pathbbox
	newpath
	end
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
 	Mwidth
	Mheight
	Mlp
	translate
	scale
	/yscale exch def
	/ybias exch def
	/xscale exch def
	/xbias exch def
	/Momatrix
	xscale yscale matrix scale
	xbias ybias matrix translate
	matrix concatmatrix def
	/Mgmatrix
	matrix currentmatrix def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabsproc {
	0
        matrix defaultmatrix
        dtransform idtransform
	dup mul exch
	dup mul
	add sqrt
} bind def
/Mabswid {	
        Mabsproc
	setlinewidth	
} bind def
/Mabsdash {	
        exch
        [
        exch
        {
        Mabsproc
        }
        forall
        ]
        exch
        setdash
} bind def
/MBeginOrig { Momatrix concat} bind def
/MEndOrig { Mgmatrix setmatrix} bind def
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse
% Here are the short operators
/g { setgray} bind def
/k { setcmykcolor} bind def
/m { moveto} bind def
/p { gsave} bind def
/r { setrgbcolor} bind def
/w { setlinewidth} bind def
/C { curveto} bind def
/F { fill} bind def
/L { lineto} bind def
/P { grestore} bind def
/s { stroke} bind def


%
% now simple conversion of cmykcolor to rgbcolor
% subtract k and then take complements
/setcmykcolor where
{ pop}
{ /setcmykcolor {	 % c m y k
	4 1
	roll			% k c m y
	[			% k c m y [
	4 1 
	roll			% k [  c m y
	] 			% k [ c m y ]
	{
	1 index		% k elem k
	sub			% k elem-k
	1
	sub neg		% k 1-(elem-k)
	dup
	0
	lt
	{
	pop
	0
	}
	if
	dup
	1
	gt
	{
	pop
	1
	}
	if
	exch		% 1-(elem-k) k
	} forall	% r g b k
	pop
	setrgbcolor
} bind def
} ifelse

/Mcharproc	% max
{
  	currentfile
  	(x)
  	readhexstring
  	pop		% max val
  	0 get
  	exch		% val max
 	div		% nval
} bind def

/Mshadeproc	% max ncols
{
	dup		% max ncols ncols
	3 1
	roll		% ncols max ncols
	{		% ncols max 
	dup		% ncols max max
	Mcharproc		% ncols max val
	3 1
	roll		% v1.. ncols max
	} repeat
	1 eq
	{
	setgray
	}
	{
	3 eq
	{
	setrgbcolor
	}
	{
	setcmykcolor
	} ifelse
	} ifelse
} bind def

/Mrectproc % x0 x1 y0 y1
{
	3 index         % x0 x1 y0 y1 x0
	2 index         % x0 x1 y0 y1 x0 y0
	moveto          % x0 x1 y0 y1
	2 index         % x0 x1 y0 y1 x1
	3 -1
	roll            % x0 x1 y1 x1 y0
	lineto          % x0 x1 y1
	dup             % x0 x1 y1 y1
	3 1
	roll            % x0 y1 x1 y1
	lineto          % x0 y1
	lineto
	fill
} bind def

/Mcolorimage     % nx ny depth matrix proc bool ncols
{
	7 1
	roll		% ncols nx ny depth matrix proc bool
	pop
	pop
	matrix
	invertmatrix
	concat          % ncols nx ny depth
	2 exch exp      % ncols nx ny 2^depth
	1 sub           % ncols nx ny max
	3 1 roll        % ncols max nx ny
	1 1             % ncols max nx ny 1 1
	2 index         % ncols max nx ny 1 1 ny
	{               % ncols max nx ny iy
	1 1             % ncols max nx ny iy 1 1
	4 index         % ncols max nx ny iy 1 1 nx
	{               % ncols max nx ny iy ix
	dup             % ncols max nx ny iy ix ix
	1 sub           % ncols max nx ny iy ix x0
	exch            % ncols max nx ny iy x0 x1
	2 index         % ncols max nx ny iy x0 x1 iy
	dup             % ncols max nx ny iy x0 x1 iy iy
	1 sub           % ncols max nx ny iy x0 x1 iy y0
	exch            % ncols max nx ny iy x0 x1 y0 y1
	7 index         % ncols max nx ny iy x0 x1 y0 y1 max
	9 index		% ncols max nx ny iy x0 x1 y0 y1 max ncols
	Mshadeproc	% ncols max nx ny iy x0 x1 y0 y1
	Mrectproc        % max nx ny iy
	} for           % x loop
	pop             % max nx ny
	} for           % y loop
	pop pop pop pop
} bind def

/Mimage  % nx ny depth matrix proc
{
	pop
	matrix
	invertmatrix
	concat          % nx ny depth
	2 exch exp      % nx ny 2^depth
	1 sub           % nx ny max
	3 1 roll        % max nx ny
	1 1             % max nx ny 1 1
	2 index         % max nx ny 1 1 ny
	{               % max nx ny iy
	1 1             % max nx ny iy 1 1
	4 index         % max nx ny iy 1 1 nx
	{               % max nx ny iy ix
	dup             % max nx ny iy ix ix
	1 sub           % max nx ny iy ix x0
	exch            % max nx ny iy x0 x1
	2 index         % max nx ny iy x0 x1 iy
	dup             % max nx ny iy x0 x1 iy iy
	1 sub           % max nx ny iy x0 x1 iy y0
	exch            % max nx ny iy x0 x1 y0 y1
	7 index         % max nx ny iy x0 x1 y0 y1 max
	Mcharproc	% max nx ny iy x0 x1 y0 y1 val
	setgray         % max nx ny iy x0 x1 y0 y1
	Mrectproc        % max nx ny iy
	} for           % x loop
	pop             % max nx ny
	} for           % y loop
	pop pop pop
} bind def


%MFill fills the drawing area with the current color.
/MFill {
	-1 -1 		moveto
	Mwidth 1 add -1 	lineto
	Mwidth 1 add Mheight 1 add 	lineto
	-1 Mheight 1 add 	lineto
	fill
} bind def

% xmin xmax ymin ymax MPlotRegion alters the origin, Mwidth and Mheight 
% so that the picture fills the altered region
/MPlotRegion {		% xmin xmax ymin ymax MPlotRegion
	3 index		% xmin xmax ymin ymax xmin
	Mwidth mul	% xmin xmax ymin ymax xmin_pos
	2 index		% xmin xmax ymin ymax xmin_pos ymin
	Mheight mul	% xmin xmax ymin ymax xmin_pos ymin_pos
	translate	% xmin xmax ymin ymax
	exch sub	% xmin xmax ymax-ymin
	Mheight mul	% xmin xmax new_height
	/Mheight
	exch def	% xmin xmax
	exch sub	% xmax-xmin
	Mwidth mul	% new-width
	/Mwidth
	exch def
} bind def
/colorimage {Mcolorimage} bind def
/image {Mimage} bind def
/Mleft		1.000000 def
/Mbottom	281.000000 def
/Mwidth		280.000000 def
/Mheight	280.000000 def
/Courier findfont 12 scalefont setfont
/Mfontsize 10 def
/Plain /Courier findfont def
/Courier findfont 10 scalefont setfont
0 Mbottom Mheight neg add 2 mul Mheight add translate
1 -1 scale
%!
%%Creator: Mathematica
%%AspectRatio: 1 
MathPictureStart
%% Graphics3D
/Courier findfont 10  scalefont  setfont
% Scaling calculations
0.02381 0.952381 0.02381 0.952381 [
[ 0 0 0 0 ]
[ 1 1 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
[ ] 0 setdash
0 g
0 0 m
1 0 L
1 1 L
0 1 L
closepath
clip
newpath
p
P
p
.02 w
.95351 .95351 Mdot
P
p
.02 w
.04649 .95351 Mdot
P
p
.02 w
.95351 .04649 Mdot
P
p
.02 w
.27324 .5 Mdot
P
p
.02 w
.5 .27324 Mdot
P
p
.02 w
.04649 .04649 Mdot
P
p
.0055 w
.04649 .95351 m
.95351 .95351 L
s
P
p
.0055 w
.95351 .04649 m
.95351 .95351 L
s
P
p
.0055 w
.27324 .5 m
.95351 .95351 L
s
P
p
.0055 w
.27324 .5 m
.04649 .95351 L
s
P
p
.0055 w
.5 .27324 m
.95351 .95351 L
s
P
p
.0055 w
.5 .27324 m
.95351 .04649 L
s
P
p
.0055 w
.5 .27324 m
.27324 .5 L
s
P
p
.0055 w
.04649 .04649 m
.04649 .95351 L
s
P
p
.0055 w
.04649 .04649 m
.95351 .04649 L
s
P
p
.0055 w
.04649 .04649 m
.27324 .5 L
s
P
p
.0055 w
.04649 .04649 m
.5 .27324 L
s
P
p
P
p
P
% End of Graphics
MathPictureEnd
%%PSTrailer
end

%%EPS Trailer

%%EndDocument
count __NXEPSOpCount sub {pop} repeat countdictstack __NXEPSDictCount sub {end} repeat __NXEPSSave restore
grestore
grestore
0 0 0 setup
gsave
/Times-Bold findfont 16 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
[1 0 0 -1 0 847] concat
/Times-Bold findfont 18 scalefont [1 0 0 -1 0 0] makefont
91
exch
defineuserobject
91 execuserobject setfont
0 nxsetgray
101 430 moveto (1) show
grestore
grestore
0 0 0 setup
gsave
91 execuserobject setfont
0 nxsetgray
[1 0 0 -1 0 955] concat
91 execuserobject setfont
0 nxsetgray
244 484 moveto (2) show
grestore
grestore
0 0 0 setup
gsave
91 execuserobject setfont
0 nxsetgray
[1 0 0 -1 0 1121] concat
91 execuserobject setfont
0 nxsetgray
163 567 moveto (3) show
grestore
grestore
0 0 0 setup
gsave
91 execuserobject setfont
0 nxsetgray
[1 0 0 -1 0 841] concat
91 execuserobject setfont
0 nxsetgray
382 427 moveto (4) show
grestore
grestore
0 0 0 setup
gsave
91 execuserobject setfont
0 nxsetgray
[1 0 0 -1 0 1387] concat
91 execuserobject setfont
0 nxsetgray
103 700 moveto (5) show
grestore
grestore
0 0 0 setup
gsave
91 execuserobject setfont
0 nxsetgray
[1 0 0 -1 0 1393] concat
91 execuserobject setfont
0 nxsetgray
382 703 moveto (6) show
grestore
grestore
0 setgray
0.333333 setgray
gsave
0 0 523 770 rectclip
[1 0 0 -1 0 770] concat
grestore
grestore
%%Trailer
%%DocumentFonts: Times-Bold
