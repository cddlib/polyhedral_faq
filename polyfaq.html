<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>Frequently Asked Questions in Polyhedral Computation</title> 
<meta charset='iso-8859-1' /> 
<meta content='TeX4ht (http://www.tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link type='text/css' rel='stylesheet' href='polyfaq.css' /> 
<meta content='polyfaq.tex' name='src' /> 
 <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=MML_HTMLorMML'></script>  
</head><body>
   <div class='maketitle'>
                                                                                           
                                                                                           
                                                                                           
                                                                                           

<h2 class='titleHead'>Frequently Asked Questions in Polyhedral Computation</h2>
                 <div class='author'><span class='cmr-12x-x-120'>Komei Fukuda</span>
<br />          <span class='cmr-12x-x-120'>ETH Zurich, Switzerland</span>
<br />             <span class='cmr-12x-x-120'>fukuda@math.ethz.ch</span>
<br /><a href='https://people.inf.ethz.ch/fukudak/' class='url'><span class='cmtt-12x-x-120'>https://people.inf.ethz.ch/fukudak/</span></a> </div><br />
<div class='date'><span class='cmr-12x-x-120'>Version Jan 15, 2022</span></div>
   </div>
<div class='center'>
<!-- l. 75 --><p class='noindent'>
</p><!-- l. 76 --><p class='noindent'><img height='113' alt='PIC' width='113' src='Figures/vtest_fig_vo.png' /> <img height='113' alt='PIC' width='116' src='Figures/vtest_fig_vo3d.png' /> <img height='113' alt='PIC' width='113' src='Figures/vtest_fig_vode.png' /></p></div>
   <h3 class='likesectionHead'><a id='x1-1000'></a>Contents</h3>
   <div class='tableofcontents'>
   <span class='sectionToc'>1 <a id='QQ2-1-2' href='#x1-20001'>What is Polyhedral Computation FAQ?</a></span>
<br />   <span class='sectionToc'>2 <a id='QQ2-1-3' href='#x1-30002'>Convex Polyhedron</a></span>
<br />    <span class='subsectionToc'>2.1 <a id='QQ2-1-4' href='#x1-40002.1'>What is convex polytope/polyhedron?</a></span>
<br />    <span class='subsectionToc'>2.2 <a id='QQ2-1-5' href='#x1-50002.2'>What are the faces of a convex polytope/polyhedron?</a></span>
<br />    <span class='subsectionToc'>2.3 <a id='QQ2-1-6' href='#x1-60002.3'>What is the face lattice of a convex polytope</a></span>
<br />    <span class='subsectionToc'>2.4 <a id='QQ2-1-7' href='#x1-70002.4'>What is a dual of a convex polytope?</a></span>
<br />    <span class='subsectionToc'>2.5 <a id='QQ2-1-8' href='#x1-80002.5'>What is simplex?</a></span>
<br />    <span class='subsectionToc'>2.6 <a id='QQ2-1-9' href='#x1-90002.6'>What is cube/hypercube/cross polytope?</a></span>
<br />    <span class='subsectionToc'>2.7 <a id='QQ2-1-10' href='#x1-100002.7'>What is simple/simplicial polytope?</a></span>
<br />    <span class='subsectionToc'>2.8 <a id='QQ2-1-11' href='#x1-110002.8'>What is 0-1 polytope?</a></span>
<br />    <span class='subsectionToc'>2.9  <a id='QQ2-1-12' href='#x1-120002.9'>What  is  the  best  upper  bound  of  the  numbers  of
<!-- l. 13 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>-dimensional
faces                                    of                                    a
<!-- l. 13 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope
with <!-- l. 13 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> vertices?</a></span>
<br />    <span class='subsectionToc'>2.10 <a id='QQ2-1-13' href='#x1-130002.10'>What is convex hull? What is the convex hull problem?</a></span>
<br />    <span class='subsectionToc'>2.11 <a id='QQ2-1-14' href='#x1-140002.11'>What is the Minkowski-Weyl theorem for convex polyhedra? </a></span>
                                                                                           
                                                                                           
<br />    <span class='subsectionToc'>2.12 <a id='QQ2-1-15' href='#x1-150002.12'>What is the vertex enumeration problem, and what is
the facet enumeration problem?</a></span>
<br />    <span class='subsectionToc'>2.13 <a id='QQ2-1-16' href='#x1-160002.13'>How can one enumerate all faces of a convex polyhedron?</a></span>
<br />    <span class='subsectionToc'>2.14 <a id='QQ2-1-17' href='#x1-170002.14'>What computer models are appropriate for the polyhedral
computation?</a></span>
<br />    <span class='subsectionToc'>2.15 <a id='QQ2-1-18' href='#x1-180002.15'>How do we measure the complexity of a convex hull algorithm?</a></span>
<br />    <span class='subsectionToc'>2.16  <a id='QQ2-1-19' href='#x1-190002.16'>How  many  facets  does  the  average  polytope  with
<!-- l. 20 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> vertices
in <!-- l. 20 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> have?</a></span>
<br />    <span class='subsectionToc'>2.17   <a id='QQ2-1-20' href='#x1-200002.17'>How   many   facets   can   a   0-1   polytope   with
<!-- l. 21 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> vertices
in <!-- l. 21 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> have?</a></span>
<br />    <span class='subsectionToc'>2.18  <a id='QQ2-1-21' href='#x1-210002.18'>How  hard  is  it  to  verify  that  an  H-polyhedron
<!-- l. 22 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math>
and                             a                             V-polyhedron
<!-- l. 22 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub></math> are equal?</a></span>
<br />    <span class='subsectionToc'>2.19 <a id='QQ2-1-22' href='#x1-220002.19'>Is there an efficient way of determining whether a given
point <!-- l. 23 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi></math>
is    in    the    convex    hull    of    a    given    finite    set
<!-- l. 23 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> of points
in <!-- l. 23 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</a></span>
<br />    <span class='subsectionToc'>2.20   <a id='QQ2-1-23' href='#x1-230002.20'>How   can   one   remove   all   interior   points   of
<!-- l. 24 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> from
<!-- l. 24 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> for large
clouds <!-- l. 24 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> of
points in <!-- l. 24 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</a></span>
<br />    <span class='subsectionToc'>2.21 <a id='QQ2-1-24' href='#x1-240002.21'>Is there any efficient algorithm to remove redundant
inequalities from a system of linear inequalities</a></span>
<br />    <span class='subsectionToc'>2.22 <a id='QQ2-1-25' href='#x1-250002.22'>Is there any efficient algorithm to compute the intersection of two (or
<!-- l. 26 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>) polytopes</a></span>
<br />    <span class='subsectionToc'>2.23 <a id='QQ2-1-26' href='#x1-260002.23'>Is there any efficient algorithm to compute the volume of a convex
polytope in <!-- l. 27 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</a></span>
<br />   <span class='sectionToc'>3 <a id='QQ2-1-27' href='#x1-270003'>Voronoi Diagram and Delaunay Triangulation</a></span>
<br />    <span class='subsectionToc'>3.1 <a id='QQ2-1-28' href='#x1-280003.1'>What is cell complex? What is triangulation?</a></span>
<br />    <span class='subsectionToc'>3.2        <a id='QQ2-1-29' href='#x1-290003.2'>What        is        Voronoi        diagram        in
<!-- l. 30 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</a></span>
<br />    <span class='subsectionToc'>3.3     <a id='QQ2-1-30' href='#x1-300003.3'>What     is     the     Delaunay     triangulation     in
<!-- l. 31 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>? </a></span>
<br />    <span class='subsectionToc'>3.4 <a id='QQ2-1-31' href='#x1-310003.4'>Computing the Delaunay complex and the Voronoi diagram.
What does it mean and how to do it with available software?</a></span>
<br />     <span class='subsubsectionToc'>3.4.1 <a id='QQ2-1-32' href='#x1-320003.4.1'>Sample session with cddlib</a></span>
<br />    <span class='subsectionToc'>3.5 <a id='QQ2-1-33' href='#x1-330003.5'>Is it possible to compute only the adjacencies of Voronoi
cells in the Voronoi diagram efficiently?</a></span>
<br />     <span class='subsubsectionToc'>3.5.1 <a id='QQ2-1-34' href='#x1-340003.5.1'>Sample session with cddlib</a></span>
<br />    <span class='subsectionToc'>3.6 <a id='QQ2-1-35' href='#x1-350003.6'>Is it possible to compute only the edges of the Delaunay
                                                                                           
                                                                                           
complex (triangulation) ?</a></span>
<br />    <span class='subsectionToc'>3.7 <a id='QQ2-1-36' href='#x1-360003.7'>Is it possible to determine the Delaunay cell containing a
given point efficiently?</a></span>
<br />     <span class='subsubsectionToc'>3.7.1 <a id='QQ2-1-37' href='#x1-370003.7.1'>Sample session with cddlib</a></span>
<br />    <span class='subsectionToc'>3.8 <a id='QQ2-1-38' href='#x1-380003.8'>What is the best upper bound of the numbers of simplices
in the Delaunay triangulation?</a></span>
<br />   <span class='sectionToc'>4 <a id='QQ2-1-39' href='#x1-390004'>Linear Programming</a></span>
<br />    <span class='subsectionToc'>4.1 <a id='QQ2-1-40' href='#x1-400004.1'>What is LP?</a></span>
<br />   <span class='sectionToc'>5 <a id='QQ2-1-41' href='#x1-410005'>Polyhedral Computation Codes</a></span>
<br />   <span class='sectionToc'>6 <a id='QQ2-1-42' href='#x1-420006'>Acknowledgements</a></span>
   </div>
<!-- l. 85 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>1   </span> <a id='x1-20001'></a>What is Polyhedral Computation FAQ?</h3>
<!-- l. 87 --><p class='noindent'>This is an FAQ to answer some basic questions arising from certain geometric computation in
general dimensional (mostly Euclidean) space. The main areas to be covered are
the convex hull computation of a finite point set, the vertex enumeration for a
convex polytope, the computation of Voronoi diagram and Delaunay triangulation, in
<!-- l. 92 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>. We
illustrate typical solution processes with small examples and publicly available codes such as cddlib
<span class='cite'>[<a href='#Xf-cddhome'>Fuka</a>]</span> and lrslib <span class='cite'>[<a href='#Xa-lrshome-01'>Avi</a>]</span>.
</p><!-- l. 96 --><p class='indent'>   It is still incomplete and perhaps contains a number of typos and mistakes at this moment, but I
will try to make it as complete as possible for the primary purposes.
</p><!-- l. 100 --><p class='indent'>   We do not intend to discuss techniques and algorithms specially designed for particular
dimensions (e.g. 2D and 3D). For those interested primarily in geometric computation in lower
dimensions (e.g. 2 and 3) should consult the comp.graphics.algorithms FAQ <span class='cite'>[<a href='#Xo-cgafaq'>O’R</a>]</span> as well as a
handbook of discrete and computational geometry <span class='cite'>[<a href='#Xgo-hbdcg-97'>Ge97</a>]</span>.
</p><!-- l. 108 --><p class='indent'>   Please note that the Polyhedral Computation FAQ is available from <span class='cite'>[<a href='#Xf-kfhome'>Fukb</a>]</span> in pdf format. The
html version might become available as well, and it has an advantage of having html links within the
documents. Yet, one has to be aware of the fact that some conversion errors exist that give wrong
equation numberings and missing figures. Please consider the pdf version as the most reliable
source.
</p><!-- l. 116 --><p class='indent'>   We do not provide any proofs for the stated results in this document. The basic theory and
computational algorithms on convex polyhedra are presented with rigorous proofs in the textbook
<span class='cite'>[<a href='#Xf-pc-20'>Fuk20b</a>]</span>.
</p><!-- l. 120 --><p class='indent'>   To refer to this document, please use
      </p><div class='quote'>
      <!-- l. 122 --><p class='noindent'>Komei Fukuda<br class='newline' />Polyhedral computation FAQ<br class='newline' />ETH Zurich, Switzerland<br class='newline' />fukuda@math.ethz.ch<br class='newline' /><a href='https://people.inf.ethz.ch/fukudak/' class='url'><span class='cmtt-12'>https://people.inf.ethz.ch/fukudak/</span></a>.</p></div>
<!-- l. 128 --><p class='noindent'>Please send your comments to the email address above.
</p>
   <h3 class='sectionHead'><span class='titlemark'>2   </span> <a id='x1-30002'></a>Convex Polyhedron</h3>
<!-- l. 131 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.1   </span> <a id='x1-40002.1'></a>What is convex polytope/polyhedron?</h4>
<!-- l. 133 --><p class='noindent'>A subset <!-- l. 133 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
of <!-- l. 133 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is called
a <span class='cmti-12'>convex polyhedron </span>if it is the set of solutions to a finite system of linear inequalities, and called <span class='cmti-12'>convex
</span><span class='cmti-12'>polytope </span>if it is a convex polyhedron and bounded. When a convex polyhedron (or polytope) has dimension
<!-- l. 136 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>, it is called a
<!-- l. 137 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math><span class='cmti-12'>-polyhedron</span>
(<!-- l. 137 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math><span class='cmti-12'>-polytope</span>).
For the sequel, we might omit <span class='cmbx-12'>convex </span>for convex polytopes and polyhedra, and call them simply
polytopes and polyhedra.
</p><!-- l. 141 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.2   </span> <a id='x1-50002.2'></a>What are the faces of a convex polytope/polyhedron?</h4>
<!-- l. 143 --><p class='noindent'>Let <!-- l. 143 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> be a convex
<!-- l. 143 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polyhedron
(or <!-- l. 143 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope)
in <!-- l. 143 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>.
</p><!-- l. 145 --><p class='indent'>   For a real <!-- l. 145 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-vector
<!-- l. 145 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math> and a real
number <!-- l. 145 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>, a linear
inequality <!-- l. 146 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>c</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>d</mi></math> is
called <span class='cmti-12'>valid </span>for <!-- l. 147 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
if <!-- l. 147 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>c</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>d</mi></math> holds for
all <!-- l. 147 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <mi>P</mi></math>. A subset
<!-- l. 148 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>F</mi></math> of a polyhedron
<!-- l. 148 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> is called a
<span class='cmti-12'>face </span>of <!-- l. 148 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
if it is represented as </p><table class='equation-star'><tr><td>
                                                                                           
                                                                                           
<!-- l. 150 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                                  <mi>F</mi> <mo class='MathClass-rel'>=</mo> <mi>P</mi> <mo class='MathClass-bin'>∩</mo><mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-punc'>:</mo> <msup><mrow><mi>c</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>=</mo> <mi>d</mi></mrow><mo class='MathClass-close'>}</mo></mrow>
</math></td></tr></table>
<!-- l. 153 --><p class='indent'>   for some valid inequality <!-- l. 153 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>c</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>d</mi></math>. By
this definition, both the empty set <!-- l. 154 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>∅</mi></math>
and the whole set <!-- l. 154 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
are faces. These two faces are called <span class='cmti-12'>improper </span>faces while the other faces are called <span class='cmti-12'>proper</span>
faces.
</p><!-- l. 158 --><p class='indent'>   We can define faces geometrically. For this, we need to define the notion of supporting hyperplanes. A
hyperplane <!-- l. 160 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>h</mi></math> of
<!-- l. 160 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is <span class='cmti-12'>supporting</span>
<!-- l. 161 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> if one of the two
closed halfspaces of <!-- l. 161 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>h</mi></math>
contains <!-- l. 161 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>.
A subset <!-- l. 162 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>F</mi></math>
of <!-- l. 162 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> is called
a <span class='cmti-12'>face </span>of <!-- l. 162 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> if
it is either <!-- l. 163 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>∅</mi></math>,
<!-- l. 163 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> itself or the
intersection of <!-- l. 164 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
with a supporting hyperplane.
</p><!-- l. 166 --><p class='indent'>   The faces of dimension <!-- l. 166 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>0</mn></math>,
<!-- l. 166 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>1</mn></math>,
<!-- l. 166 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi class='MathClass-op'> dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-bin'>-</mo> <mn>2</mn></math> and
<!-- l. 166 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi class='MathClass-op'> dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-bin'>-</mo> <mn>1</mn></math> are called
the <span class='cmti-12'>vertices</span>, <span class='cmti-12'>edges</span>, <span class='cmti-12'>ridges </span>and <span class='cmti-12'>facets</span>, respectively. The vertices coincide with the <span class='cmti-12'>extreme points </span>of
<!-- l. 169 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> which
are defined as points which cannot be represented as convex combinations of two other points in
<!-- l. 170 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>. When
an edge is not bounded, there are two cases: either it is a line or a half-line starting from a vertex. A
half-line edge is called an <span class='cmti-12'>extreme ray</span>.
</p><!-- l. 175 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.3   </span> <a id='x1-60002.3'></a>What is the face lattice of a convex polytope</h4>
<!-- l. 178 --><p class='noindent'>The <span class='cmti-12'>face poset </span><!-- l. 178 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>FL</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> of a convex
polyhedron is the set of all faces of <!-- l. 179 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
                                                                                           
                                                                                           
ordered by set inclusion. Two polytopes are called <span class='cmti-12'>isomorphic </span>if their face posets are isomorphic.
The face poset of a convex polytope is a lattice.
</p><!-- l. 184 --><p class='indent'>   The face poset of a convex polyhedron is sometimes referred to as the <span class='cmti-12'>combinatorial structure </span>of
the polyhedron. Thus the expression “two polyhedra are combinatorially equal” means they are
isomorphic.
</p><!-- l. 189 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.4   </span> <a id='x1-70002.4'></a>What is a dual of a convex polytope?</h4>
<!-- l. 191 --><p class='noindent'>For a convex polytope <!-- l. 191 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>,
any convex polytope <!-- l. 191 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>P</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
with <!-- l. 191 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>FL</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>P</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math> anti-isomorphic
to <!-- l. 192 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>FL</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> (i.e. “upside-down”
of <!-- l. 192 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>FL</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>) is called a
<span class='cmti-12'>(combinatorial) dual </span>of <!-- l. 193 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>.
By the definition, a dual polytope has the same dimension as
<!-- l. 194 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>. The
duality theorem states that every convex polytope admits a dual.
</p>
   <div class='newtheorem'>
<!-- l. 197 --><p class='noindent'><span class='head'>
<span class='cmbx-12'>Theorem 1 (Duality of Polytopes)</span> </span><a id='x1-70011'></a> <span class='cmti-12'>Every nonempty</span>
<!-- l. 198 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math><span class='cmti-12'>-polytope</span>
<!-- l. 198 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> <span class='cmti-12'>in</span>
<!-- l. 198 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> <span class='cmti-12'>admits a dual
</span><span class='cmti-12'>polytope in </span><!-- l. 199 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math><span class='cmti-12'>.
</span><span class='cmti-12'>In particular, one can construct a dual polytope by the following “polar” construction:</span>
</p><table class='equation-star'><tr><td>
<!-- l. 201 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                           <msup><mrow><mi>P</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>y</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup> <mo class='MathClass-punc'>:</mo> <msup><mrow><mi>x</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>y</mi> <mo class='MathClass-rel'>≤</mo> <mn>1</mn><mstyle class='text'><mtext> for all </mtext></mstyle><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <mi>P</mi></mrow><mo class='MathClass-close'>}</mo></mrow>
</math></td></tr></table>
<!-- l. 204 --><p class='indent'>   <span class='cmti-12'>where</span>
<!-- l. 204 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
<span class='cmti-12'>is assumed to contain the origin in its interior.</span>
                                                                                           
                                                                                           
</p>
   </div>
<!-- l. 207 --><p class='indent'>   When <!-- l. 207 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> contains the origin
in its interior, the polytope <!-- l. 208 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>P</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup></math>
is called the <span class='cmti-12'>polar </span>of <!-- l. 208 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>.
One can easily show that </p><table class='equation-star'><tr><td>
<!-- l. 210 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                         <msup><mrow><mi>P</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>y</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup> <mo class='MathClass-punc'>:</mo> <msup><mrow><mi>v</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>y</mi> <mo class='MathClass-rel'>≤</mo> <mn>1</mn><mstyle class='text'><mtext> for all </mtext></mstyle><mi>v</mi> <mo class='MathClass-rel'>∈</mo> <mi>V</mi> <mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>}</mo></mrow>
</math></td></tr></table>
<!-- l. 213 --><p class='indent'>   where <!-- l. 213 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>V</mi> <mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> denote the set of
vertices of <!-- l. 213 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>V</mi> </math>, and this inequality
(H-) representation of <!-- l. 214 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>P</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup></math>
is minimal (i.e. contains no redundant inequalities).
</p><!-- l. 217 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.5   </span> <a id='x1-80002.5'></a>What is simplex?</h4>
<!-- l. 219 --><p class='noindent'>A subset <!-- l. 219 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
of <!-- l. 219 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is called
a <!-- l. 219 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math><span class='cmti-12'>-simplex</span>
(<!-- l. 219 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi> <mo class='MathClass-rel'>=</mo> <mn>0</mn><mo class='MathClass-punc'>,</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo> <mn>2</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></math>) if it is the convex hull
of <!-- l. 220 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></math> affinely independent
points. It has exactly <!-- l. 221 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></math>
vertices and <!-- l. 221 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></math> facets. A
simplex is a <!-- l. 222 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>-simplex
for some <!-- l. 222 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>.
</p><!-- l. 224 --><p class='indent'>   Simplices are selfdual, i.e. a dual (see <a href='#x1-70002.4'>2.4<!-- tex4ht:ref: polytope:dual  --></a>) of a simplex is again a simplex.
</p><!-- l. 226 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.6   </span> <a id='x1-90002.6'></a>What is cube/hypercube/cross polytope?</h4>
<!-- l. 228 --><p class='noindent'>A subset <!-- l. 228 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> of
<!-- l. 228 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is called a <span class='cmti-12'>unit</span>
<!-- l. 228 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math><span class='cmti-12'>-cube </span>if it is the convex
                                                                                           
                                                                                           
hull of all <!-- l. 229 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mn>2</mn></mrow><mrow><mi>d</mi></mrow></msup></math> points
with components <!-- l. 229 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>0</mn></math>
or <!-- l. 229 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>1</mn></math>. It has
exactly <!-- l. 230 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mn>2</mn></mrow><mrow><mi>d</mi></mrow></msup></math>
vertices and <!-- l. 230 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>2</mn><mi>d</mi></math>
facets. A <span class='cmti-12'>cube </span>or <span class='cmti-12'>hypercube </span>is a convex polytope which is isomorphic to the
<!-- l. 232 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-cube for
some <!-- l. 233 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>.
</p><!-- l. 235 --><p class='indent'>   A dual (see <a href='#x1-70002.4'>2.4<!-- tex4ht:ref: polytope:dual  --></a>) of a cube is called a <span class='cmti-12'>cross </span>polytope.
</p><!-- l. 238 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.7   </span> <a id='x1-100002.7'></a>What is simple/simplicial polytope?</h4>
<!-- l. 240 --><p class='noindent'>A <!-- l. 240 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope
is called <span class='cmbx-12'>simple </span>if each vertex is contained in exactly
<!-- l. 241 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math> facets. A
<!-- l. 241 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope is called <span class='cmbx-12'>simplicial</span>
if each facet contains exactly <!-- l. 242 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
vertices. By definition, a dual of simple (simlicial) polytope is simplicial (simple, respectively). Every facet of a
simplicial <!-- l. 245 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope is
a <!-- l. 245 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math>-simplex. Each vertex
of a simple <!-- l. 246 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope is
contained in exactly <!-- l. 246 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-edges.
</p><!-- l. 248 --><p class='indent'>   A <!-- l. 248 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-cube is a simple
polytope and a <!-- l. 248 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-simplex
is both simple and simplicial.
</p><!-- l. 251 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.8   </span> <a id='x1-110002.8'></a>What is 0-1 polytope?</h4>
<!-- l. 253 --><p class='noindent'>A polytope in <!-- l. 253 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is called
<span class='cmbx-12'>0-1 </span>if all its vertices are in <!-- l. 254 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mrow><mo class='MathClass-open'>{</mo><mrow><mn>0</mn><mo class='MathClass-punc'>,</mo> <mn>1</mn></mrow><mo class='MathClass-close'>}</mo></mrow></mrow><mrow><mi>d</mi></mrow></msup></math>.
In other words, a 0-1 polytope is the convex hull of a subset of the
<!-- l. 255 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mn>2</mn></mrow><mrow><mi>d</mi></mrow></msup></math> point
set <!-- l. 255 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mrow><mo class='MathClass-open'>{</mo><mrow><mn>0</mn><mo class='MathClass-punc'>,</mo> <mn>1</mn></mrow><mo class='MathClass-close'>}</mo></mrow></mrow><mrow><mi>d</mi></mrow></msup></math>, for
some <!-- l. 256 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math>.
</p><!-- l. 259 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.9   </span> <a id='x1-120002.9'></a>What is the best upper bound of the numbers of
<!-- l. 259 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>-dimensional faces
                                                                                           
                                                                                           
of a <!-- l. 259 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope
with <!-- l. 259 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
vertices?</h4>
<!-- l. 261 --><p class='noindent'>Let <!-- l. 261 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> denote the
number of <!-- l. 261 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>-faces
of a <!-- l. 261 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope
<!-- l. 261 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>, for
<!-- l. 262 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi> <mo class='MathClass-rel'>=</mo> <mn>0</mn><mo class='MathClass-punc'>,</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>d</mi></math>.
</p><!-- l. 264 --><p class='indent'>   The exact upper bound for <!-- l. 264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub></math>
in terms of <!-- l. 264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>f</mi></mrow><mrow><mn>0</mn></mrow></msub></math>
and <!-- l. 264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>. is
known, thanks to McMullen’s upper bound theorem.
</p><!-- l. 267 --><p class='indent'>   The convex hull of distinct <!-- l. 267 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
points on the moment curve <!-- l. 268 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>{</mo><mrow><mi>m</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>t</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc'>,</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msup><mrow><mi>t</mi></mrow><mrow><mi>d</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-punc'>:</mo> <mi>t</mi> <mo class='MathClass-rel'>∈</mo> <mi>R</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math>
in <!-- l. 268 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is known as
a <span class='cmti-12'>cyclic polytope</span>. It is known that its combinatorial structure (i.e. its face lattice, see Section <a href='#x1-60002.3'>2.3<!-- tex4ht:ref: polytope:facelattice  --></a>) is uniquely
determined by <!-- l. 272 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> and
<!-- l. 272 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>. Thus we often write
<!-- l. 273 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> to denote any such
cyclic <!-- l. 274 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope
with <!-- l. 274 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
vertices.
</p><!-- l. 276 --><p class='indent'>   McMullen’s Upper Bound Theorem shows that the maximum of
<!-- l. 277 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> is
attained by the cyclic polytopes.
</p>
   <div class='newtheorem'>
<!-- l. 279 --><p class='noindent'><span class='head'>
<span class='cmbx-12'>Theorem 2 (Upper Bound Theorem)</span> </span><a id='x1-120012'></a> <span class='cmti-12'>For any</span>
<!-- l. 280 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math><span class='cmti-12'>-polytope
</span><span class='cmti-12'>with </span><!-- l. 280 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
<span class='cmti-12'>vertices,</span> </p><table class='equation-star'><tr><td>
<!-- l. 281 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                           <msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>≤</mo> <msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mspace width='0.28em' class='thickpace'></mspace><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>k</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo>
</math></td></tr></table>
                                                                                           
                                                                                           
<!-- l. 284 --><p class='indent'>   <span class='cmti-12'>holds.</span>
</p>
   </div>
<!-- l. 287 --><p class='indent'>   The number of <!-- l. 287 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>-faces
of a cyclic polytope <!-- l. 287 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
can be explicitely given and thus one can evaluate the order of the upper bound in terms of
<!-- l. 289 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> and
<!-- l. 289 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>.
</p>
   <div class='newtheorem'>
<!-- l. 291 --><p class='noindent'><span class='head'>
<span class='cmbx-12'>Theorem 3</span> </span><a id='x1-120023'></a> <span class='cmti-12'>For </span><!-- l. 292 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>≥</mo> <mn>2</mn></math>
<span class='cmti-12'>and </span><!-- l. 292 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>0</mn> <mo class='MathClass-rel'>≤</mo> <mi>k</mi> <mo class='MathClass-rel'>≤</mo> <mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></math><span class='cmti-12'>,</span>
</p><table class='equation-star'><tr><td>
<!-- l. 293 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
            <msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo><munderover accentunder='false' accent='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>r</mi><mo class='MathClass-rel'>=</mo><mn>0</mn></mrow><mrow><mrow><mo class='MathClass-open'>⌊</mo><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow><mo class='MathClass-close'>⌋</mo></mrow></mrow></munderover><mfenced open='(' close=')' separators=''><mfrac linethickness='0.0pt'><mrow><mi>n</mi> <mo class='MathClass-bin'>-</mo> <mi>d</mi> <mo class='MathClass-bin'>+</mo> <mi>r</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow>
        <mrow><mi>r</mi></mrow></mfrac></mfenced><mfenced open='(' close=')' separators=''><mfrac linethickness='0.0pt'><mrow>       <mi>r</mi></mrow> 
<mrow><mi>k</mi></mrow></mfrac></mfenced> <mo class='MathClass-bin'>+</mo><munderover accentunder='false' accent='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>r</mi><mo class='MathClass-rel'>=</mo><mrow><mo class='MathClass-open'>⌊</mo><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow><mo class='MathClass-close'>⌋</mo></mrow><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><mfenced open='(' close=')' separators=''><mfrac linethickness='0.0pt'><mrow><mi>n</mi> <mo class='MathClass-bin'>-</mo> <mi>r</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow>
   <mrow><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mi>r</mi></mrow></mfrac></mfenced><mfenced open='(' close=')' separators=''><mfrac linethickness='0.0pt'><mrow>   <mi>r</mi></mrow> 
<mrow><mi>k</mi></mrow></mfrac></mfenced>
</math></td></tr></table>
<!-- l. 299 --><p class='indent'>   <span class='cmti-12'>. In particular,</span>
</p><!-- tex4ht:inline --><!-- l. 304 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                     <mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mi>f</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>-</mo><mn>1</mn></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow></mtd>                     <mtd class='align-even'> <mo class='MathClass-rel'>=</mo><mfenced open='(' close=')' separators=''><mfrac linethickness='0.0pt'><mrow> <mi>n</mi> <mo class='MathClass-bin'>-</mo><mfenced open='⌈' close='⌉' separators=''><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow></mfenced></mrow> 
    <mrow><mfenced open='⌊' close='⌋' separators=''><mrow><mfrac><mrow><mi>d</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac></mrow></mfenced></mrow></mfrac></mfenced>       <mo class='MathClass-bin'>+</mo><mfenced open='(' close=')' separators=''><mfrac linethickness='0.0pt'><mrow> <mi>n</mi> <mo class='MathClass-bin'>-</mo><mfenced open='⌊' close='⌋' separators=''><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow></mfenced> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow> 
    <mrow><mfenced open='⌈' close='⌉' separators=''><mrow><mfrac><mrow><mi>d</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac></mrow></mfenced> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow></mfrac></mfenced>    <mspace width='2em'></mspace></mtd>                                          <mtd class='align-label' columnalign='right'><mstyle id='x1-12003r1' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(1)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
                     </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                  <mtd class='align-even'> <mo class='MathClass-rel'>=</mo> <mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mfenced open='⌊' close='⌋' separators=''><mrow><mfrac><mrow><mi>d</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> 
   </mrow></mfenced>
    </mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow><mstyle class='text'><mtext>   for any fixed </mtext><mstyle class='math'><mi>d</mi></mstyle><mtext></mtext></mstyle><mo class='MathClass-punc'>.</mo><mspace width='2em'></mspace></mtd>                                          <mtd class='align-label' columnalign='right'><mstyle id='x1-12004r2' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(2)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
                                                                                           
                                                                                           
   </div>
<!-- l. 308 --><p class='noindent'>For example,
</p>
   <table class='equation-star'><tr><td>
<!-- l. 311 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
 <mtable equalrows='false' style='' align='axis' columnlines='none none none none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'><mi>P</mi>       </mtd><mtd class='array' columnalign='right'><msub><mrow><mi>f</mi></mrow><mrow><mn>0</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <msub><mrow><mi>f</mi></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd class='array' columnalign='right'>  <msub><mrow><mi>f</mi></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd class='array' columnalign='right'>  <msub><mrow><mi>f</mi></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <msub><mrow><mi>f</mi></mrow><mrow><mn>4</mn></mrow></msub></mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mn>5</mn><mo class='MathClass-punc'>,</mo> <mn>10</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mtd><mtd class='array' columnalign='right'><mn>10</mn></mtd><mtd class='array' columnalign='right'> <mn>45</mn></mtd><mtd class='array' columnalign='right'> <mn>100</mn></mtd><mtd class='array' columnalign='right'> <mn>105</mn></mtd><mtd class='array' columnalign='right'> <mn>42</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mn>5</mn><mo class='MathClass-punc'>,</mo> <mn>20</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mtd><mtd class='array' columnalign='right'><mn>20</mn></mtd><mtd class='array' columnalign='right'><mn>190</mn></mtd><mtd class='array' columnalign='right'> <mn>580</mn></mtd><mtd class='array' columnalign='right'> <mn>680</mn></mtd><mtd class='array' columnalign='right'><mn>272</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mn>5</mn><mo class='MathClass-punc'>,</mo> <mn>30</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mtd><mtd class='array' columnalign='right'><mn>30</mn></mtd><mtd class='array' columnalign='right'><mn>435</mn></mtd><mtd class='array' columnalign='right'><mn>1460</mn></mtd><mtd class='array' columnalign='right'><mn>1755</mn></mtd><mtd class='array' columnalign='right'><mn>702</mn></mtd></mtr><!-- lrrrrr --></mtable>
</math></td></tr></table>
<!-- l. 320 --><p class='indent'>   The upper bound theorem can be written in dual form which gives, for example, the maximum number of
vertices in a <!-- l. 322 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-polytope
with <!-- l. 322 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math>
facets.
</p>
   <div class='newtheorem'>
<!-- l. 324 --><p class='noindent'><span class='head'>
<span class='cmbx-12'>Theorem 4 (Upper Bound Theorem in Dual Form)</span> </span><a id='x1-120054'></a> <span class='cmti-12'>For any</span>
<!-- l. 325 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math><span class='cmti-12'>-polytope
</span><span class='cmti-12'>with </span><!-- l. 325 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math>
<span class='cmti-12'>facets,</span> </p><table class='equation-star'><tr><td>
<!-- l. 326 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                        <msub><mrow><mi>f</mi></mrow><mrow><mi>k</mi></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>P</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>≤</mo> <msub><mrow><mi>f</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>-</mo><mi>k</mi><mo class='MathClass-bin'>-</mo><mn>1</mn></mrow></msub><mrow><mo class='MathClass-open'>(</mo><mrow><mi>C</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>m</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mspace width='0.28em' class='thickpace'></mspace><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>k</mi> <mo class='MathClass-rel'>=</mo> <mn>0</mn><mo class='MathClass-punc'>,</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>2</mn><mo class='MathClass-punc'>,</mo>
</math></td></tr></table>
<!-- l. 329 --><p class='indent'>   <span class='cmti-12'>holds.</span>
</p>
   </div>
                                                                                           
                                                                                           
<!-- l. 333 --><p class='indent'>   The original proof of the Upper Bound Theorem is in <span class='cite'>[<a href='#Xm-mnfcp-70'>McM70</a>, <a href='#Xms-cpuc-71'>MS71</a>]</span>. There are different
variations, see <span class='cite'>[<a href='#Xk-lpsasp-97'>Kal97</a>, <a href='#Xm-cg-94'>Mul94</a>, <a href='#Xz-lop-94'>Zie94</a>]</span>. The textbook <span class='cite'>[<a href='#Xf-pc-20'>Fuk20b</a>, Chap 6]</span> presents a detailed proof
based on <span class='cite'>[<a href='#Xk-lpsasp-97'>Kal97</a>]</span> which is beautiful but has a little typo.
</p><!-- l. 340 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.10   </span> <a id='x1-130002.10'></a>What is convex hull? What is the convex hull problem?</h4>
<!-- l. 343 --><p class='noindent'>For a subset <!-- l. 343 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> of
<!-- l. 343 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>, the convex hull
<!-- l. 343 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> is defined as the
smallest convex set in <!-- l. 344 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
containing <!-- l. 344 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>.
</p><!-- l. 346 --><p class='indent'>   The convex hull computation means the “determination” of
<!-- l. 347 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> for a given
finite set of <!-- l. 347 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
points <!-- l. 348 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><msup><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc'>,</mo><msup><mrow><mi>p</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msup><mrow><mi>p</mi></mrow><mrow><mi>n</mi></mrow></msup></mrow><mo class='MathClass-close'>}</mo></mrow></math>
in <!-- l. 349 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>.
</p><!-- l. 351 --><p class='indent'>   The usual way to determine <!-- l. 351 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
is to represent it as the intersection of halfspaces, or more precisely, as a set of
solutions to a minimal system of linear inequalities. This amounts to output a matrix
<!-- l. 354 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>A</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>m</mi><mo class='MathClass-bin'>×</mo><mi>d</mi></mrow></msup></math> and a
vector <!-- l. 355 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>m</mi></mrow></msup></math> for
some <!-- l. 355 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math> such
that <!-- l. 356 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi><mo class='MathClass-rel'>|</mo><mi>A</mi><mspace width='0.28em' class='thickpace'></mspace><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math>.
When <!-- l. 357 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
is full-dimensional, each (nonredundant) inequality corresponds to a facet of
<!-- l. 359 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>. Thus
the convex hull problem is also known as the <span class='cmti-12'>facet enumeration problem</span>, see Section
<a href='#x1-150002.12'>2.12<!-- tex4ht:ref: polytope:repconv  --></a>.
</p><!-- l. 363 --><p class='indent'>   Some people define the convex hull computation as the determination of extreme points of
<!-- l. 364 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>, or equivalently that
of redundant points in <!-- l. 365 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>
to determine <!-- l. 365 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>.
This is much simpler computation than our convex hull problem. In fact, this can be done by solving
<!-- l. 367 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> linear programs
and thus polynomially solvable, see Section <a href='#x1-220002.19'>2.19<!-- tex4ht:ref: polytope:Vredundancy  --></a> and <a href='#x1-230002.20'>2.20<!-- tex4ht:ref: polytope:Vredundancy2  --></a>. It is better to name this as the “redundancy removal
for a point set <!-- l. 370 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>”.
</p><!-- l. 373 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.11   </span> <a id='x1-140002.11'></a>What is the Minkowski-Weyl theorem for convex polyhedra? </h4>
<!-- l. 376 --><p class='noindent'>The Minkowski-Weyl Theorem states every polyhedron is finitely generated and
                                                                                           
                                                                                           
every finitely generated set is a polyhedron. More precisely, for two subsets
<!-- l. 379 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> and
<!-- l. 379 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>Q</mi></math> of
<!-- l. 379 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>,
<!-- l. 379 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-bin'>+</mo> <mi>Q</mi></math> denotes the
<span class='cmti-12'>Minkowski sum </span>of <!-- l. 380 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
and <!-- l. 380 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>Q</mi></math>:
<!-- tex4ht:inline --></p><!-- l. 381 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'>
<mtable class='eqnarray-star' columnalign='right center left'>
<mtr><mtd class='eqnarray-1'> <mi>P</mi> <mo class='MathClass-bin'>+</mo> <mi>Q</mi></mtd><mtd class='eqnarray-2'>   <mo class='MathClass-rel'>=</mo></mtd><mtd class='eqnarray-3'>   <mrow><mo class='MathClass-open'>{</mo><mrow><mi>p</mi> <mo class='MathClass-bin'>+</mo> <mi>q</mi> <mo class='MathClass-punc'>:</mo> <mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>P</mi><mstyle class='mbox'><mtext> and </mtext></mstyle><mi>q</mi> <mo class='MathClass-rel'>∈</mo> <mi>Q</mi></mrow><mo class='MathClass-close'>}</mo></mrow><mo class='MathClass-punc'>.</mo></mtd><mtd class='eqnarray-4'> <mtext class='eqnarray'></mtext></mtd>                                                  </mtr></mtable>
</math>
<!-- l. 384 --><p class='nopar'>
</p>
   <div class='newtheorem'>
<!-- l. 386 --><p class='noindent'><span class='head'>
<span class='cmbx-12'>Theorem 5 (Minkowski-Weyl’s Theorem)</span> </span><a id='x1-140025'></a> <span class='cmti-12'>For a subset</span>
<!-- l. 387 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> <span class='cmti-12'>of</span>
<!-- l. 387 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math><span class='cmti-12'>, the
</span><span class='cmti-12'>following statements are equivalent:</span>
      </p><dl class='description'><dt class='description'>
<span class='cmbx-12'>(a)</span> </dt><dd class='description'><span class='cmti-12'>P is a polyhedron, i.e., for some real (finite) matrix </span><!-- l. 389 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>A</mi></math>
      <span class='cmti-12'>and real vector </span><!-- l. 389 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi></math><span class='cmti-12'>,</span>
      <!-- l. 390 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-punc'>:</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math><span class='cmti-12'>;</span>
      </dd><dt class='description'>
<span class='cmbx-12'>(b)</span> </dt><dd class='description'><span class='cmti-12'>There are finite real vectors </span><!-- l. 392 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
      <span class='cmti-12'>and </span><!-- l. 393 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>r</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><msub><mrow><mi>r</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>r</mi></mrow><mrow><mi>s</mi></mrow></msub></math>
      <span class='cmti-12'>in </span><!-- l. 393 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
      <span class='cmti-12'>such that</span><br class='newline' /><!-- l. 395 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-rel'>=</mo> <mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-bin'>+</mo> <mi mathvariant='italic'>nonneg</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msub><mrow><mi>r</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><msub><mrow><mi>r</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>r</mi></mrow><mrow><mi>s</mi></mrow></msub></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmti-12'>.</span></dd></dl>
                                                                                           
                                                                                           
</div>
<!-- l. 399 --><p class='indent'>   Thus, every polyhedron has two representations of type (a) and (b), known as (halfspace)
<span class='cmti-12'>H-representation </span>and (vertex) <span class='cmti-12'>V-representation</span>, respectively. A polyhedron given by
H-representation (V-representation) is called <span class='cmti-12'>H-polyhedron </span>(<span class='cmti-12'>V-polyhedron</span>).
</p><!-- l. 406 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.12   </span> <a id='x1-150002.12'></a>What is the vertex enumeration problem, and what is the facet enumeration
problem?</h4>
<!-- l. 408 --><p class='noindent'>When a polyhedron <!-- l. 408 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
in <!-- l. 408 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
has at least one extreme point and full dimensional, both representations (a) and (b) in
Miknowski-Weyl Theorem <a href='#x1-140025'>5<!-- tex4ht:ref: thm:Minkowski-Weyl1  --></a> are unique up positive multiples of each inequality and ray
<!-- l. 411 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>r</mi></mrow><mrow><mi>j</mi></mrow></msub></math>.
</p><!-- l. 413 --><p class='indent'>   Under these regularity conditions, the conversions between the H-representation and the
V-representation are well-defined fundamental problems. The transformation (a) to (b) is known as
the <span class='cmti-12'>vertex enumeration </span>and the other (b) to (a) is known as the <span class='cmti-12'>facet enumeration</span>. When
<!-- l. 417 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> is in
addition bounded (i.e. polytope), the facet enumeration problem reduces to what we call the convex
hull problem, see <a href='#x1-130002.10'>2.10<!-- tex4ht:ref: polytope:convhullcomp  --></a>.
</p><!-- l. 421 --><p class='indent'>   If a given polyhedron does not satisfy the assumptions, it is easy to transform the polyhedron to
an isomorphic lower dimensional polyhedron satisfying the assumptions.
</p><!-- l. 425 --><p class='indent'>   There are easy (nondegenerate) cases and difficult (degenerate) cases. For simplicity, we assume
that <!-- l. 426 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> is
bounded (i.e. polytope). The vertex enumeration is called <span class='cmti-12'>nondegenerate </span>if there is no point
<!-- l. 428 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> which
satisfies <!-- l. 428 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></math>
given inequalities with equality, and <span class='cmti-12'>degenerate </span>otherwise. The facet enumeration is called <span class='cmti-12'>nondegenerate </span>if
there is no <!-- l. 432 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math>
given points which are on a common hyperplane, and <span class='cmti-12'>degenerate </span>otherwise.
</p><!-- l. 435 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.13   </span> <a id='x1-160002.13'></a>How can one enumerate all faces of a convex polyhedron?</h4>
<!-- l. 437 --><p class='noindent'>Let <!-- l. 437 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> be a convex
polytope in <!-- l. 437 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>. One
can extend the discussion below for the unbounded case (polyhedron) by adding a face at infinity, but for simplicity
we assume <!-- l. 439 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
is bounded.
</p><!-- l. 441 --><p class='indent'>   First of all the answer does not depend on how
<!-- l. 441 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> is
given. The problem for H-polytopes is equivalent to the one for V-polytopes by duality. See Sections
                                                                                           
                                                                                           
<a href='#x1-140002.11'>2.11<!-- tex4ht:ref: polytope:MWtheorem  --></a> and <a href='#x1-70002.4'>2.4<!-- tex4ht:ref: polytope:dual  --></a>.
</p><!-- l. 446 --><p class='indent'>   There are algorithms (e.g. <span class='cite'>[<a href='#Xr-dchhd-92'>Rot92</a>, <a href='#Xs-chdch-86'>Sei86</a>, <a href='#Xflm-abala-97'>FLM97</a>]</span> ) that can generate all faces from a
V-representation or from a H-rerepsentation. Perhaps the backtrack algorithm <span class='cite'>[<a href='#Xflm-abala-97'>FLM97</a>]</span> is easiest to
implement and works directly for the unbounded case. It is also a compact polynomial algorithm
(see <a href='#x1-180002.15'>2.15<!-- tex4ht:ref: polytope:rconvcomplexity  --></a>) and thus needs little space to run. Algorithms that need to store all faces during
computation tend to be too complicated to implement, because one needs to manage a complex data
structure of faces and their incidences.
</p><!-- l. 458 --><p class='indent'>   Another approach to generate all faces consists of two steps.
      </p><dl class='description'><dt class='description'>
<span class='cmbx-12'>(1)</span> </dt><dd class='description'>Firstly compute the second representation by a representation conversion algorithm.
      </dd><dt class='description'>
<span class='cmbx-12'>(2)</span> </dt><dd class='description'>Secondly use a combinatorial method to genrate all faces.</dd></dl>
<!-- l. 466 --><p class='noindent'>The first part is discussed in Section <a href='#x1-180002.15'>2.15<!-- tex4ht:ref: polytope:rconvcomplexity  --></a> and Section <a href='#x1-410005'>5<!-- tex4ht:ref: Sec:codes  --></a> presents some existing implementation. The
second part can be done efficiently by purely combinatorial computation, see <span class='cite'>[<a href='#Xfr-cfecp-94'>FR94</a>]</span>. As explained in
<span class='cite'>[<a href='#Xfr-cfecp-94'>FR94</a>]</span>, when the polytope is simple (simplicial), the face listing without duplication can be done
implicitely by sorting the vertices (the facets) by a generic linear function (a generic line through an
interior point).
</p><!-- l. 478 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.14   </span> <a id='x1-170002.14'></a>What computer models are appropriate for the polyhedral computation?</h4>
<!-- l. 480 --><p class='noindent'>There are two important computational models, the unit cost RAM (random access machine) and
the Turing machine. The essential difference is that the Turing machine uses the binary
representations of numbers and the computational time is measured precisely down to the number
of (unit cost) bit operations. I believe that the RAM model, in which each elementary
arithmetic operation takes a unit time and each integer number takes a unit space, is the
standard model for the polyhedral computation. This model, despite its simplicity, often
illuminates the critical parts of an algorithm and thus reflects the actual computation well. Of
course, ignoring the number of bits of a largest number arising in the computation is
dangerous, if one does not control the exponential growth of bit lengths of the numbers (in
terms of the input bit length). This warning should be always kept in mind to design
a good implementation. Furthermore, there are certain cases in which we need to use
the Turing complexity. For example, all known “polynomial” algorithms for the linear
programming (see Section <a href='#x1-390004'>4<!-- tex4ht:ref: Sec:LP  --></a>) are Turing polynomial but not RAM polynomial. We may avoid
this problem by pretending that there were a RAM polynomial algorithm for LP. After
all, we (those interested in geometric computation) are interested in an analysis which
reflects the reality and the simplex method for LP is practically a RAM polynomial (or
equivalently, strongly polynomial) method. We refer to the recent book <span class='cite'>[<a href='#Xy-fpaa-00'>Yap00</a>]</span> for further
discussions.
                                                                                           
                                                                                           
</p><!-- l. 511 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.15   </span> <a id='x1-180002.15'></a>How do we measure the complexity of a convex hull algorithm?</h4>
<!-- l. 513 --><p class='noindent'>To answer this question, we assume the unit cost RAM model, where the computational time is
essentially the number of elementary arithmetic operations and the storage for any integer number
takes a unit space. See Section <a href='#x1-170002.14'>2.14<!-- tex4ht:ref: polytope:computermodel  --></a>.
</p><!-- l. 518 --><p class='indent'>   There are two approaches to evaluate the complexity of a given convex hull algorithm.
</p><!-- l. 521 --><p class='indent'>   Let <!-- l. 521 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math>
be an algorithm which computes a minimal inequality description
<!-- l. 522 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-punc'>:</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math> of a full-dimensional
convex polytope <!-- l. 523 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-rel'>=</mo> <mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> for
a given point set <!-- l. 524 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>
in <!-- l. 524 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> with
<!-- l. 525 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi> <mo class='MathClass-rel'>=</mo> <mo class='MathClass-rel'>|</mo><mi>S</mi><mo class='MathClass-rel'>|</mo></math>. Let
<!-- l. 525 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math> denote the number of
inequalities in the output <!-- l. 526 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math>.
</p><!-- l. 528 --><p class='indent'>   (One can interprete the discussion here in dual setting: consider
<!-- l. 529 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math> as an algorithm to
compute all vertices <!-- l. 530 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>S</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
of a convex polytope <!-- l. 530 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-punc'>:</mo> <msup><mrow><mi>A</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow><mo class='MathClass-close'>}</mo></mrow></math>
with <!-- l. 531 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> inequaities
with <!-- l. 531 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math>
vertices.)
</p><!-- l. 533 --><p class='indent'>   First of all, most people agree that the efficiency of computing the
convex hull should be measured at least by the critical input parameters
<!-- l. 536 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math> and
<!-- l. 536 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>. Some people like to see
the complexity by fixing <!-- l. 537 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
to constant, but it is always better to evaluate in terms of
<!-- l. 539 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math> as
well, and fix it later.
</p><!-- l. 541 --><p class='indent'>   The first measure, often employed by computational geometers, is to bound the worst case running time of
an algorithm <!-- l. 542 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math>
for any input with <!-- l. 543 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
points in <!-- l. 543 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>. For
example, if <!-- l. 543 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math> is of
<!-- l. 544 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>!</mo><mspace width='0.28em' class='thickpace'></mspace><msup><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>, then it means
<!-- l. 544 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math> terminates in
time <!-- l. 545 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>!</mo><mspace width='0.28em' class='thickpace'></mspace><msup><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math> for ANY
input of <!-- l. 545 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> points
in dimension <!-- l. 545 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>. Also,
when one set <!-- l. 546 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
to be fixed (constant), such an algorithm is said to have time complexity
<!-- l. 547 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>, since
<!-- l. 547 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi><mo class='MathClass-punc'>!</mo></math> is
                                                                                           
                                                                                           
simply a constant. We may call this <span class='cmti-12'>worst-case-input measure</span>. For fixed dimension, there is an
optimum algorithm <span class='cite'>[<a href='#Xc-ochaa-93'>Cha93</a>]</span> for the convex hull in terms of the worst-case-input measure, that runs
in time <!-- l. 551 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mrow><mo class='MathClass-open'>⌊</mo><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow><mo class='MathClass-close'>⌋</mo></mrow></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>
for <!-- l. 552 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>≥</mo> <mn>4</mn></math>. It
cannot be better because the largest output is of the same order by the upper bound theorem
(Theorem <a href='#x1-120012'>2<!-- tex4ht:ref: thm:MUB  --></a>).
</p><!-- l. 556 --><p class='indent'>   The worst-case-input measure is quite popular, but it might be little misleading. For example, suppose
algorithms <!-- l. 558 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math> and
<!-- l. 558 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>β</mi></math> are of time
complexity <!-- l. 559 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math> and
<!-- l. 559 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn><mi>d</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>, respectively. Then by this
measurement, the algorithm <!-- l. 560 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math>
is <span class='cmti-12'>superior to </span><!-- l. 560 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>β</mi></math>.
</p><!-- l. 562 --><p class='indent'>   Here is a potentially serious problem with this worst-case-input measure. Above, it is still possible that
<!-- l. 563 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math> takes worst-case
time <!-- l. 563 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></msup></math> for ALL
input of <!-- l. 564 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> points
in <!-- l. 564 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>, and
<!-- l. 564 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>β</mi></math> takes time proportional to
some polynomial function of <!-- l. 565 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi><mo class='MathClass-punc'>,</mo><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>m</mi></math>.
Note that the number <!-- l. 566 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math> of
inequalities varies wildly from <!-- l. 567 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math>
to <!-- l. 567 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mrow><mo class='MathClass-open'>⌊</mo><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow><mo class='MathClass-close'>⌋</mo></mrow></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>, even
for fixed <!-- l. 567 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
(by the upper bound theorem Theorem <a href='#x1-120012'>2<!-- tex4ht:ref: thm:MUB  --></a> and (<a href='#x1-12003r1'>1<!-- tex4ht:ref: polytope:FacetUB  --></a>)). This diversity is just too big to be ignored if
<!-- l. 569 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>≥</mo> <mn>4</mn></math>.
Furthermore, the input data leading to the worst-case output hardly occurs
in practice. In fact, for the random spherical polytope, the expected size of
<!-- l. 572 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math> is <span class='cmbx-12'>linear
</span><span class='cmbx-12'>in </span><!-- l. 572 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>, see
Section <a href='#x1-190002.16'>2.16<!-- tex4ht:ref: polytope:expectedHcomplexity  --></a>. While the worst-case-input optimal algorithm <span class='cite'>[<a href='#Xc-ochaa-93'>Cha93</a>]</span> is a remarkable theoretical
achievement, <span class='cmbx-12'>we are still very far from knowing the best ways to compute the convex hull
</span><span class='cmbx-12'>for general dimensions</span>.
</p><!-- l. 579 --><p class='indent'>   In order to circumvent this pitfall, one can use a measure using all key variables
<!-- l. 580 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi><mo class='MathClass-punc'>,</mo><mi>m</mi></math>. Or more
generally, one can measure the time complexity in terms of both the size of input and the size of output. We
say an algorithm <!-- l. 583 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>α</mi></math>
is <span class='cmti-12'>polynomial  </span>if it runs in time bounded by a polynomial in
<!-- l. 584 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi><mo class='MathClass-punc'>,</mo><mi>m</mi></math>. This
polynomiality coincides with the usual polynomiality when the output size is polynomially bounded
by the size of input.
</p><!-- l. 589 --><p class='indent'>   Under the nondegeneracy assumption (see <a href='#x1-150002.12'>2.12<!-- tex4ht:ref: polytope:repconv  --></a>), there is a polynomial algorithm for the
convex hull problem. Few of the earlier polynomial algorithms are pivot-based algorithms
<span class='cite'>[<a href='#Xcch-itlp-53'>CCH53</a>, <a href='#Xd-cvem-83'>Dye83</a>]</span> solving the problem in dual form (the vertex enumeration problem)
and a wrapping algorithm <span class='cite'>[<a href='#Xck-acp-70'>CK70</a>]</span>. A more recent algorithm <span class='cite'>[<a href='#Xaf-pachv-92'>AF92</a>]</span> based on reverse
                                                                                           
                                                                                           
search technique <span class='cite'>[<a href='#Xaf-rse-96'>AF96</a>]</span> is not only polynomial but <span class='cmti-12'>compact </span>at the same time. Here,
we say an algorithm is <span class='cmti-12'>compact </span>if its space complexity is polynomial in the input size
only.
</p><!-- l. 600 --><p class='indent'>   In the general case, there is no known polynomial algorithm. The paper <span class='cite'>[<a href='#Xabs-hgach-97'>ABS97</a>]</span> is an excellet
article presenting how various algorithms fail to be polynomial, through ingenious constructions of
“nasty” polytopes.
</p><!-- l. 606 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.16   </span> <a id='x1-190002.16'></a>How many facets does the average polytope with
<!-- l. 606 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> vertices in
<!-- l. 606 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
have?</h4>
<!-- l. 609 --><p class='noindent'>Clearly we need to define a probability distribution of points to answer the question.
</p><!-- l. 612 --><p class='indent'>   Perhaps the most interesting describution for which the answer is known is the uniform distribution on the
unit sphere <!-- l. 613 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>S</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>-</mo><mn>1</mn></mrow></msup></math>.
The results of Buchta et al <span class='cite'>[<a href='#Xbmt-sacb-85'>BMT85</a>]</span> show that the expected number of facets is
<!-- l. 615 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-punc'>,</mo><mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mfrac><mrow><mn>2</mn></mrow> 
<mrow><mi>d</mi></mrow></mfrac><mi>γ</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mrow><mn>2</mn></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow><mi>γ</mi><msup><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mrow><mo class='MathClass-bin'>-</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-bin'>-</mo><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow></msup><mrow><mo class='MathClass-open'>(</mo><mrow><mi>n</mi> <mo class='MathClass-bin'>+</mo> <mi>o</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow></math> assymtotically with
<!-- l. 616 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi> <mo class='MathClass-rel'>→</mo><mi>∞</mi></math>. The important fact is
that it depends linearly on <!-- l. 617 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
essentially. Here the function <!-- l. 618 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>γ</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
is defined recursively by
</p><!-- tex4ht:inline --><!-- l. 622 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align-star' columnalign='left'>
                                    <mtr><mtd class='align-odd' columnalign='right'><mi>γ</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mtd>                                    <mtd class='align-even'> <mo class='MathClass-rel'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mspace width='2em'></mspace></mtd>                                               <mtd class='align-label' columnalign='right'></mtd>                                    <mtd class='align-label'>
                                    <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mi>γ</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mtd>                                    <mtd class='align-even'> <mo class='MathClass-rel'>=</mo>        <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn><mspace width='0.28em' class='thickpace'></mspace><mi>π</mi><mspace width='0.28em' class='thickpace'></mspace><mi>p</mi><mspace width='0.28em' class='thickpace'></mspace><mi>γ</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow></mfrac><mo class='MathClass-punc'>.</mo><mspace width='2em'></mspace></mtd>                                    <mtd class='align-label' columnalign='right'></mtd>                                    <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 623 --><p class='noindent'>Just to see how large the slope <!-- l. 624 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>g</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mfrac><mrow><mn>2</mn></mrow> 
<mrow><mi>d</mi></mrow></mfrac><mi>γ</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mrow><mn>2</mn></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow><mi>γ</mi><msup><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mrow><mo class='MathClass-bin'>-</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-bin'>-</mo><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow></msup></math>
of this “linear” function in <!-- l. 625 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
is, we calculate it for <!-- l. 626 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>≤</mo> <mn>15</mn></math>:
</p>
                                                                                           
                                                                                           
<div class='center'>
<!-- l. 627 --><p class='noindent'>
</p>
<div class='tabular'> <table id='TBL-3' class='tabular'><colgroup id='TBL-3-1g'><col id='TBL-3-1' /><col id='TBL-3-2' /></colgroup><tr id='TBL-3-1-' style='vertical-align:baseline;'><td id='TBL-3-1-1' style='text-align:right; white-space:nowrap;' class='td11'><!-- l. 629 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math></td><td id='TBL-3-1-2' style='text-align:right; white-space:nowrap;' class='td11'><!-- l. 629 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>g</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math></td>
</tr><tr id='TBL-3-2-' style='vertical-align:baseline;'><td id='TBL-3-2-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                             2</td><td id='TBL-3-2-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            1</td></tr><tr id='TBL-3-3-' style='vertical-align:baseline;'><td id='TBL-3-3-1' style='text-align:right; white-space:nowrap;' class='td11'> 3</td><td id='TBL-3-3-2' style='text-align:right; white-space:nowrap;' class='td11'> 2</td>
</tr><tr id='TBL-3-4-' style='vertical-align:baseline;'><td id='TBL-3-4-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                             4</td><td id='TBL-3-4-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                       6.76773</td></tr><tr id='TBL-3-5-' style='vertical-align:baseline;'><td id='TBL-3-5-1' style='text-align:right; white-space:nowrap;' class='td11'> 5</td><td id='TBL-3-5-2' style='text-align:right; white-space:nowrap;' class='td11'> 31.7778</td>
</tr><tr id='TBL-3-6-' style='vertical-align:baseline;'><td id='TBL-3-6-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                             6</td><td id='TBL-3-6-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                       186.738</td></tr><tr id='TBL-3-7-' style='vertical-align:baseline;'><td id='TBL-3-7-1' style='text-align:right; white-space:nowrap;' class='td11'> 7</td><td id='TBL-3-7-2' style='text-align:right; white-space:nowrap;' class='td11'> 1296.45</td>
</tr><tr id='TBL-3-8-' style='vertical-align:baseline;'><td id='TBL-3-8-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                             8</td><td id='TBL-3-8-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                       10261.8</td>
</tr><tr id='TBL-3-9-' style='vertical-align:baseline;'><td id='TBL-3-9-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                             9</td><td id='TBL-3-9-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                       90424.6</td>
</tr><tr id='TBL-3-10-' style='vertical-align:baseline;'><td id='TBL-3-10-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            10</td><td id='TBL-3-10-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                       872190.</td>
</tr><tr id='TBL-3-11-' style='vertical-align:baseline;'><td id='TBL-3-11-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            11</td><td id='TBL-3-11-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                  9.09402 E+06</td>
</tr><tr id='TBL-3-12-' style='vertical-align:baseline;'><td id='TBL-3-12-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            12</td><td id='TBL-3-12-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                  1.01518 E+08</td>
</tr><tr id='TBL-3-13-' style='vertical-align:baseline;'><td id='TBL-3-13-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            13</td><td id='TBL-3-13-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                  1.20414 E+09</td>
</tr><tr id='TBL-3-14-' style='vertical-align:baseline;'><td id='TBL-3-14-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            14</td><td id='TBL-3-14-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                  1.50832 E+10</td>
</tr><tr id='TBL-3-15-' style='vertical-align:baseline;'><td id='TBL-3-15-1' style='text-align:right; white-space:nowrap;' class='td11'>                                                                            15</td><td id='TBL-3-15-2' style='text-align:right; white-space:nowrap;' class='td11'>                                                                  1.98520 E+11</td></tr></table>
</div></div>
<!-- l. 638 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.17   </span> <a id='x1-200002.17'></a>How many facets can a 0-1 polytope with
<!-- l. 638 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> vertices in
<!-- l. 638 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
have?</h4>
<!-- l. 641 --><p class='noindent'>Let <!-- l. 641 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
denote the maximum number of facets of a 0-1 polytope in
<!-- l. 642 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>.
The question such as “is this function bounded by an exponential in
<!-- l. 643 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>?” was open
just until recently. The negative answer was given by Brny and Pr who proved the superexponential
behavior of <!-- l. 646 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>.
</p><div class='newtheorem'>
<!-- l. 647 --><p class='noindent'><span class='head'>
<span class='cmbx-12'>Theorem 6 (Brny and Pr </span><span class='cite'><span class='cmbx-12'>[</span><a href='#Xbp-01pmf-00'><span class='cmbx-12'>BP00</span></a><span class='cmbx-12'>]</span></span><span class='cmbx-12'>)</span> </span><span class='cmti-12'>There is a positive constant</span>
<!-- l. 648 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math> <span class='cmti-12'>such
</span><span class='cmti-12'>that</span>
                                                                                           
                                                                                           
</p><!-- tex4ht:inline --><!-- l. 651 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                                     <mtr><mtd class='align-odd' columnalign='right'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>&gt;</mo><msup><mrow> <mfenced open='(' close=')' separators=''><mrow>  <mfrac><mrow><mi>c</mi><mspace width='0.28em' class='thickpace'></mspace><mi>d</mi></mrow>
<mrow><mi class='qopname'> log</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --> <mi>d</mi></mrow></mfrac></mrow></mfenced></mrow><mrow><mfrac><mrow><mi>d</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-punc'>.</mo></mtd>                                     <mtd class='align-even'><mspace width='2em'></mspace></mtd>                                     <mtd class='align-label' columnalign='right'><mstyle id='x1-20002r3' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(3)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
   </div>
<!-- l. 653 --><p class='noindent'>This is a recent breakthrough in the theory of 0-1 polytopes.
</p><!-- l. 656 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.18   </span> <a id='x1-210002.18'></a>How hard is it to verify that an H-polyhedron
<!-- l. 656 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math> and a
V-polyhedron <!-- l. 656 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub></math>
are equal?</h4>
<!-- l. 659 --><p class='noindent'>This is a fundamental complexity question associated with the Minkowski-Weyl theorem (Theorem
<a href='#x1-140025'>5<!-- tex4ht:ref: thm:Minkowski-Weyl1  --></a>). This problem, known as the <span class='cmti-12'>polyhedral verification problem </span>was first posed by L. Lovasz (see
<span class='cite'>[<a href='#Xs-nhg-94'>Sey94</a>]</span>).
</p><!-- l. 664 --><p class='indent'>   To simplify our discussion, let us assume <!-- l. 664 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math>
and <!-- l. 664 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub></math>
are bounded and thus polytopes. Also we may assume that the given representations contain no
redundant data, since removing redundancies is just a matter of solving linear programs, see Sections
<a href='#x1-220002.19'>2.19<!-- tex4ht:ref: polytope:Vredundancy  --></a> and <a href='#x1-240002.21'>2.21<!-- tex4ht:ref: polytope:Hredundancy  --></a>.
</p><!-- l. 670 --><p class='indent'>   The verification consists of two questions, “is
<!-- l. 671 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub> <mo class='MathClass-rel'>⊆</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math>?” and
“is <!-- l. 671 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub> <mo class='MathClass-rel'>⊆</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub></math>?”
The first question is easy to answer by just checking whether each generator (vertex) of
<!-- l. 673 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub></math> satisfies the
H-representation of <!-- l. 674 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math>.
The second question is known to be coNP-complete, due to <span class='cite'>[<a href='#Xfo-ocfpsc-85'>FO85</a>]</span>. (It is not hard to see that it
belongs to coNP, since the negative answer to the question has a succinct certificate, a vertex
<!-- l. 678 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math> of
<!-- l. 678 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math> and a hyperplane
separating <!-- l. 679 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math>
from <!-- l. 679 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>V</mi> </mrow></msub></math>.)
Yet, the complexity of the second question, when the first question has the positive answer, is not
known.
</p><!-- l. 683 --><p class='indent'>   It is possible to prove that the polynomial solvability of this problem implies the polynomial
solvability of the representation conversion problem for general convex polytopes (i.e. the vertex
enumeration and the facet enumeration problems). Here the polynomial solvability of the
representation conversion problem means the existence of an algorithm that generates the second
minimal representation in time polynomial in the size of both input and output. See Section <a href='#x1-180002.15'>2.15<!-- tex4ht:ref: polytope:rconvcomplexity  --></a> for
                                                                                           
                                                                                           
discussion on complexity measures.
</p><!-- l. 693 --><p class='indent'>   How does the above reduction work? Assume we have a polynomial algorithm for
the verification, and we design an algorithm to generate all vertices of an H-polytope
<!-- l. 696 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math>. Let
<!-- l. 697 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>V</mi> </math> be a set of vertices
of <!-- l. 697 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math> generated
so far. Take the first inequality from the H-representation, and ask whether we have generated all vertices on
the face <!-- l. 701 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mn>1</mn></mrow></msub></math>, the
intersection of <!-- l. 701 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mi>H</mi></mrow></msub></math>
and the hyperplane given by the first inequality being forced to be equality. This is just one application
of the verification algorithm. If yes, we move to the second inequality and repeat. Otherwise, we go
down to lower dimensional face by setting one of the remaining inequality to equality. When we have
<!-- l. 708 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-independent
equalities, we compute the unique vertex by solving the equation system. The key observation is that
we generate a subproblem only when the verification algorithm returns NO answer. This means
every subproblem created generates at least one new vertex. This guarantees our generation
algorithm to be polynomial.
</p><!-- l. 715 --><p class='indent'>   I do not know who is the first to recognize this reduction. I consider this belongs to
folklore.
</p><!-- l. 718 --><p class='indent'>   Finally I repeat: the complexity of the polyhedral verification problem is unknown. Is it in P or
in coNP-complete? This is perhaps the most important question in polyhedral computation. A
fascinating question, indeed.
</p><!-- l. 728 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.19   </span> <a id='x1-220002.19'></a>Is there an efficient way of determining whether a given point
<!-- l. 728 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi></math> is in the convex hull
of a given finite set <!-- l. 728 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>
of points in <!-- l. 728 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</h4>
<!-- l. 731 --><p class='noindent'>Yes. However, we need to be careful.
</p><!-- l. 733 --><p class='indent'>   First we give a method that we do not recommend but many people use. This method computes an inequality
representation <!-- l. 735 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup> <mo class='MathClass-punc'>:</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math>
of <!-- l. 735 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> where
<!-- l. 736 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>A</mi></math> is some
<!-- l. 736 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi> <mo class='MathClass-bin'>×</mo> <mi>d</mi></math> matrix
and <!-- l. 736 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi></math> is a
<!-- l. 736 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math>-vector.
This is called the convex hull computation <a href='#x1-130002.10'>2.10<!-- tex4ht:ref: polytope:convhullcomp  --></a>. Once the system
<!-- l. 738 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math> is computed, it is easy
to check whether <!-- l. 739 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math>
satisfies the system or not.
</p><!-- l. 742 --><p class='indent'>   In most cases, this method is too expensive, since the convex hull computation is very hard in
general and impossible for large data. In fact, the number of inequalities in such a system
                                                                                           
                                                                                           
<!-- l. 745 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math> is often
exponential in <!-- l. 746 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
and <!-- l. 746 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi> <mo class='MathClass-rel'>=</mo> <mo class='MathClass-rel'>|</mo><mi>S</mi><mo class='MathClass-rel'>|</mo></math>.
(This method might be of practical interests when we need to remove lots of redundant points in
clouds of points in small dimensions, see <a href='#x1-230002.20'>2.20<!-- tex4ht:ref: polytope:Vredundancy2  --></a>.)
</p><!-- l. 751 --><p class='indent'>   A standard method to check whether <!-- l. 752 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi></math>
is in <!-- l. 752 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> uses
linear programming (LP) technique <a href='#x1-390004'>4<!-- tex4ht:ref: Sec:LP  --></a>. An LP problem to be formulated for the question is the following.
Let <!-- l. 755 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><msub><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><msub><mrow><mi>p</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>p</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo class='MathClass-close'>}</mo></mrow></math>.
</p><!-- tex4ht:inline --><!-- l. 763 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                          <mtr><mtd class='align-odd' columnalign='right'> <mtable equalrows='false' style='' align='axis' columnlines='none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'><mstyle class='text'><mtext>find</mtext></mstyle>       </mtd><mtd class='array' columnalign='left'><mi>λ</mi>                         </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'><mstyle class='text'><mtext>satisfying</mtext></mstyle></mtd><mtd class='array' columnalign='left'><mi>q</mi> <mo class='MathClass-rel'>=</mo><munderover accentunder='false' accent='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>i</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mrow><mi>λ</mi></mrow><mrow>
<mi>i</mi></mrow></msub><msub><mrow><mi>p</mi></mrow><mrow><mi>i</mi></mrow></msub>              </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>               </mtd><mtd class='array' columnalign='left'><munderover accentunder='false' accent='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>i</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mrow><mi>λ</mi></mrow><mrow>
<mi>i</mi></mrow></msub> <mo class='MathClass-rel'>=</mo> <mn>1</mn>              </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>            </mtd><mtd class='array' columnalign='left'><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mstyle class='text'><mtext> for all </mtext></mstyle><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>n</mi><mo class='MathClass-punc'>.</mo></mtd></mtr> <!-- lll --></mtable>                                                                 </mtd>                          <mtd class='align-even'><mspace width='2em'></mspace></mtd>                          <mtd class='align-label' columnalign='right'><mstyle id='x1-22001r4' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(4)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 764 --><p class='noindent'>This problem has no objective function and such a problem is often called a <span class='cmti-12'>linear feasibility
</span><span class='cmti-12'>problem</span>. Although it might look simpler problem to solve, it is polynomially equivalent
to the general LP. In fact, it is usually a good idea to set up an equivalent LP to solve
it. More specifically, the problem (<a href='#x1-22001r4'>4<!-- tex4ht:ref: eq:Vredundancy_lp1  --></a>) has a solution if and only if the following has no
solution:
</p><!-- tex4ht:inline --><!-- l. 777 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                         <mtr><mtd class='align-odd' columnalign='right'> <mtable equalrows='false' style='' align='axis' columnlines='none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'><mstyle class='text'><mtext>find</mtext></mstyle>       </mtd><mtd class='array' columnalign='left'><msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-rel'>∈</mo> <mi>R</mi><mstyle class='text'><mtext> and </mtext></mstyle><mi>z</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup>            </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'><mstyle class='text'><mtext>satisfying</mtext></mstyle></mtd><mtd class='array' columnalign='left'><msup><mrow><mi>z</mi></mrow><mrow><mi>T</mi> </mrow></msup><msub><mrow><mi>p</mi></mrow><mrow>
<mi>i</mi></mrow></msub> <mo class='MathClass-rel'>≤</mo> <msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub><mstyle class='text'><mtext> for all </mtext></mstyle><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>n</mi></mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>          </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>z</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>q</mi> <mo class='MathClass-rel'>&gt;</mo> <msub><mrow><mi>z</mi></mrow><mrow>
<mn>0</mn></mrow></msub><mo class='MathClass-punc'>.</mo>                   </mtd></mtr> <!-- lll --></mtable>                                                              </mtd>                         <mtd class='align-even'><mspace width='2em'></mspace></mtd>                         <mtd class='align-label' columnalign='right'><mstyle id='x1-22002r5' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(5)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
                                                                                           
                                                                                           
<!-- l. 778 --><p class='noindent'>Geometrically, the meaning of this problem is simple. If it admits a solution
<!-- l. 779 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi>z</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>, then the set
<!-- l. 779 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>H</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup> <mo class='MathClass-punc'>:</mo> <msup><mrow><mi>z</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>=</mo> <msub><mrow><mi>z</mi></mrow><mrow>
<mn>0</mn></mrow></msub></mrow><mo class='MathClass-close'>}</mo></mrow></math> is a hyperplane
in <!-- l. 780 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> separating the
polytope <!-- l. 780 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> from the
inquiry point <!-- l. 781 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi></math>.
Thus the existence of the separation means the nonredundancy. Now, to actually solve the problem
(<a href='#x1-22002r5'>5<!-- tex4ht:ref: eq:Vredundancy_lp2  --></a>), we set up the LP:
</p><!-- tex4ht:inline --><!-- l. 790 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                    <mtr><mtd class='align-odd' columnalign='right'> <mtable equalrows='false' style='' align='axis' columnlines='none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'><msup><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup> <mo class='MathClass-rel'>=</mo></mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>maximize</mtext></mstyle> </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>z</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>q</mi> <mo class='MathClass-bin'>-</mo> <msub><mrow><mi>z</mi></mrow><mrow>
<mn>0</mn></mrow></msub>                                        </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>         </mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>subject to</mtext></mstyle></mtd><mtd class='array' columnalign='left'><msup><mrow><mi>z</mi></mrow><mrow><mi>T</mi> </mrow></msup><msub><mrow><mi>p</mi></mrow><mrow>
<mi>i</mi></mrow></msub> <mo class='MathClass-bin'>-</mo> <msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-rel'>≤</mo> <mn>0</mn><mstyle class='text'><mtext> for all </mtext></mstyle><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>n</mi></mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>     </mtd><mtd class='array' columnalign='left'>           </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>z</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>q</mi> <mo class='MathClass-bin'>-</mo> <msub><mrow><mi>z</mi></mrow><mrow>
<mn>0</mn></mrow></msub> <mo class='MathClass-rel'>≤</mo> <mn>1</mn><mo class='MathClass-punc'>.</mo>                   </mtd></mtr> <!-- lll --></mtable>                                                   </mtd>                    <mtd class='align-even'><mspace width='2em'></mspace></mtd>                    <mtd class='align-label' columnalign='right'><mstyle id='x1-22003r6' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(6)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 791 --><p class='noindent'>The last inequality is artificially added so that the LP has a bounded solution. It is easy to see that the point
<!-- l. 792 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi></math> is non-redundant if and
only if the optimal value <!-- l. 793 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup></math>
of the LP (<a href='#x1-22003r6'>6<!-- tex4ht:ref: eq:Vredundancy_lp3  --></a>) is (strictly) positive.
</p><!-- l. 798 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.20   </span> <a id='x1-230002.20'></a>How can one remove all interior points of
<!-- l. 798 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> from
<!-- l. 798 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> for large
clouds <!-- l. 798 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> of
points in <!-- l. 798 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</h4>
<!-- l. 801 --><p class='noindent'>The problem is formally known as the <span class='cmti-12'>redundancy removal</span>. Let
<!-- l. 802 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> be a set of
<!-- l. 802 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> points
in <!-- l. 802 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>. We say
a point <!-- l. 803 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></math> is
<span class='cmti-12'>redundant </span>(for <!-- l. 803 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>)
if <!-- l. 804 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi> <mo class='MathClass-rel'>∈</mo> <mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi> <mo class='MathClass-bin'>-</mo> <mi>q</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>.
In short, redundant points are unnecessary to determine the convex hull
<!-- l. 805 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>.
                                                                                           
                                                                                           
</p><!-- l. 807 --><p class='indent'>   In principle, one can apply the linear programming (LP) method
given in <a href='#x1-220002.19'>2.19<!-- tex4ht:ref: polytope:Vredundancy  --></a> to remove all redundant points. This amounts to solving
<!-- l. 809 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> LPs.
While the time complexity of this pure LP method is polynomial and additional techniques given by
<span class='cite'>[<a href='#Xc-mosga-94'>Cla94</a>, <a href='#Xoss-eephd-95'>OSS95</a>]</span> can reduce the size of LPs, this might end up in a very time consuming job for large
<!-- l. 814 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> (say
<!-- l. 814 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'> <mo class='MathClass-rel'>&gt;</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo> <mn>000</mn></math>).
</p><!-- l. 816 --><p class='indent'>   We have recently tested Clarkson’s algorithm <span class='cite'>[<a href='#Xc-mosga-94'>Cla94</a>]</span> experimentally. Initial results posted in
<a href='https://people.inf.ethz.ch/fukudak/ClarksonExp/ExperimentCube.html' class='url'><span class='cmtt-12'>https://people.inf.ethz.ch/fukudak/ClarksonExp/ExperimentCube.html</span></a><br class='newline' />indicate a huge acceleration for highly redundant cases.
</p><!-- l. 821 --><p class='indent'>   There is a technique that might be useful to remove “obviously redundant” points
quickly as a preprocessing. This works only in small dimensions (probably up to
<!-- l. 823 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>100</mn></math>?). Such a method picks up a
few nonredundant point set <!-- l. 825 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>T</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><msub><mrow><mi>t</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>t</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow><mo class='MathClass-close'>}</mo></mrow></math>
from <!-- l. 825 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>.
Selecting nonredundant points can be done by picking points maximizing (or minimizing) any given linear
function over <!-- l. 827 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>.
When <!-- l. 828 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math> is small
relative to <!-- l. 828 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>,
say <!-- l. 828 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>2</mn></math> or
<!-- l. 828 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>3</mn></math>, the
computation of <!-- l. 829 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>T</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
is usually very easy with any standard convex hull algorithm. Thus we assume that an inequality system
<!-- l. 831 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math> such that
<!-- l. 831 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>T</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-punc'>:</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math> is given. It is easy to see
that any point <!-- l. 832 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi> <mo class='MathClass-bin'>-</mo> <mi>T</mi></math> satisfying
the inequalities (i.e. <!-- l. 833 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Aq</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math>)
is redundant. One can repeat the same procedure with a different set
<!-- l. 835 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>T</mi></mrow><mrow><mi>′</mi></mrow></msup></math> of
nonredundant points as long as it removes “sufficient number” of redundant points.
</p><!-- l. 839 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.21   </span> <a id='x1-240002.21'></a>Is there any efficient algorithm to remove redundant inequalities from a system of linear
inequalities</h4>
<!-- l. 842 --><p class='noindent'>This problem is essentially equivalent to the redundancy removal from point sets given in
<a href='#x1-230002.20'>2.20<!-- tex4ht:ref: polytope:Vredundancy2  --></a>.
</p><!-- l. 845 --><p class='indent'>   Although one can transform one to the other, let us describe a direct method. Let
<!-- l. 846 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi><mo class='MathClass-punc'>,</mo><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>t</mi></math> be a given system
of <!-- l. 846 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi></math>-inequalities
in <!-- l. 846 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-variables
<!-- l. 846 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi> <mo class='MathClass-rel'>=</mo> <msup><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>d</mi></mrow></msub></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup></math>. We want to test whether
the subsystem of first <!-- l. 847 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi> <mo class='MathClass-bin'>-</mo> <mn>1</mn></math>
                                                                                           
                                                                                           
inequalities <!-- l. 847 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math> implies
the last inequality <!-- l. 848 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>t</mi></math>.
If so, the inequality <!-- l. 849 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>t</mi></math>
is redundant and can be removed from the system. A linear programming (LP) formulation of this
checking is rather straightforward:
</p><!-- tex4ht:inline --><!-- l. 860 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                             <mtr><mtd class='align-odd' columnalign='right'> <mtable equalrows='false' style='' align='axis' columnlines='none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'><msup><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup> <mo class='MathClass-rel'>=</mo></mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>maximize</mtext></mstyle> </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi>         </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>     </mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>subject to</mtext></mstyle></mtd><mtd class='array' columnalign='left'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi>      </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>     </mtd><mtd class='array' columnalign='left'>           </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>t</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn><mo class='MathClass-punc'>.</mo></mtd></mtr> <!-- lll --></mtable>                                                                        </mtd>                             <mtd class='align-even'><mspace width='2em'></mspace></mtd>                             <mtd class='align-label' columnalign='right'><mstyle id='x1-24001r7' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(7)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 861 --><p class='noindent'>Then the inequality <!-- l. 861 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>t</mi></math> is redundant
if and only if the optimal value <!-- l. 862 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup></math>
is less than or equal to <!-- l. 862 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>t</mi></math>.
</p><!-- l. 864 --><p class='indent'>   By successively solving this LP for each untested inequality against the remaining, one would
finally obtain a equivalent non-redundant system.
</p><!-- l. 868 --><p class='indent'>   As we discussed in <a href='#x1-230002.20'>2.20<!-- tex4ht:ref: polytope:Vredundancy2  --></a>, there is a very promising idea to improve the naive LP technique
above. It is proposed by Clarkson <span class='cite'>[<a href='#Xc-mosga-94'>Cla94</a>]</span> . The main idea is the following. Let’s denote by
<!-- l. 871 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>m</mi></mrow><mrow><mi>′</mi></mrow></msup></math> the number
of nonredundant constraints which is known. Clarkson’s algorithm uses the same LP technique but for a
subsystem <!-- l. 873 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>A</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
of <!-- l. 873 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi></math> of size
at most <!-- l. 874 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>m</mi></mrow><mrow><mi>′</mi></mrow></msup></math>.
</p><!-- tex4ht:inline --><!-- l. 882 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                             <mtr><mtd class='align-odd' columnalign='right'> <mtable equalrows='false' style='' align='axis' columnlines='none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'><msup><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin'>*</mo></mrow></msup> <mo class='MathClass-rel'>=</mo></mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>maximize</mtext></mstyle> </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi>         </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>     </mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>subject to</mtext></mstyle></mtd><mtd class='array' columnalign='left'><msup><mrow><mi>A</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup>   </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'>    </mtd><mtd class='array' columnalign='left'>        </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>s</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mi>t</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn><mo class='MathClass-punc'>.</mo></mtd></mtr> <!-- lll --></mtable>                                                                        </mtd>                             <mtd class='align-even'><mspace width='2em'></mspace></mtd>                             <mtd class='align-label' columnalign='right'><mstyle id='x1-24002r8' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(8)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
                                                                                           
                                                                                           
<!-- l. 883 --><p class='noindent'>The subsystem is the currently recognized system of nonredundant constraints at some stage. If the
tested inequality is redundant for this subsystem, then obviously it is redundant for the whole
system. What can we do if the tested inequality is nonredundant? There is a so called “ray-shooting”
technique that will find a new nonredundant inequality. The detailed discussion can be found in the
textbook <span class='cite'>[<a href='#Xf-pc-20'>Fuk20b</a>, Chap 7]</span>.
</p><!-- l. 890 --><p class='indent'>   We have tested Clarkson’s algorithm <span class='cite'>[<a href='#Xc-mosga-94'>Cla94</a>]</span> experimentally. Initial results posted in
<a href='https://people.inf.ethz.ch/fukudak/ClarksonExp/ExperimentCube.html' class='url'><span class='cmtt-12'>https://people.inf.ethz.ch/fukudak/ClarksonExp/ExperimentCube.html</span></a><br class='newline' />indicate a huge acceleration for highly redundant cases.
</p><!-- l. 915 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.22   </span> <a id='x1-250002.22'></a>Is there any efficient algorithm to compute the intersection of two (or
<!-- l. 915 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>)
polytopes</h4>
<!-- l. 918 --><p class='noindent'>Let <!-- l. 918 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi> <mo class='MathClass-rel'>≥</mo> <mn>2</mn></math>, and let
<!-- l. 918 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><msub><mrow><mi>P</mi></mrow><mrow><mi>k</mi></mrow></msub></math> be input
polytopes in <!-- l. 919 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>,
and let <!-- l. 919 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi> <mo class='MathClass-rel'>=</mo> <msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin'>∩</mo> <msub><mrow><mi>P</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin'>∩</mo><mo class='MathClass-rel'>⋯</mo> <mo class='MathClass-bin'>∩</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>k</mi></mrow></msub></math>
be the polytope we want to compute.
</p><!-- l. 922 --><p class='indent'>   This problem of computing <!-- l. 922 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
needs to be specified further. Namely, what is the representation of input and that of
output?
</p><!-- l. 925 --><p class='indent'>   If the input polytopes are H-polytopes (given by inequalities) then the intersection is
represented by the union of the two inequality systems. To get a minimal H-reprentation for
the intersection is just a redundancy removal given in Section <a href='#x1-240002.21'>2.21<!-- tex4ht:ref: polytope:Hredundancy  --></a>. To get a minimal
V-representation for the intersection is the vertex enumeration problem explained in Section
<a href='#x1-150002.12'>2.12<!-- tex4ht:ref: polytope:repconv  --></a>.
</p><!-- l. 933 --><p class='indent'>   An interesting case is when both input and output polytopes are V-polytopes (i.e.
given by vertices and perhaps some redundant points). One primitive way to solve this
problem consists of two steps: (1) generate minimal H-representations of each of the input
<!-- l. 937 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>
polytopes, (2) solve the vertex enumeration problem for the union of the
<!-- l. 939 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>
H-representations. This naive approach might be satisfactory for small dimensions or
not-too-complicated polytopes. Recently, a polynomial algorithm has been found for the special case
when the input polyopes are in general position <span class='cite'>[<a href='#Xfll-ech-00'>FLL00</a>]</span>. This algorithm is not yet practical because the
general position assumption does not seem to be easily simulated for the general case. It should be
remarked that the dual version of this problem is to compute a minimal H-representation of the convex
hull of <!-- l. 947 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>k</mi></math>
H-polytopes. Actually the paper <span class='cite'>[<a href='#Xfll-ech-00'>FLL00</a>]</span> treats this dual problem.
</p><!-- l. 951 --><p class='noindent'>
                                                                                           
                                                                                           
</p>
   <h4 class='subsectionHead'><span class='titlemark'>2.23   </span> <a id='x1-260002.23'></a>Is there any efficient algorithm to compute the volume of a convex polytope in
<!-- l. 951 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</h4>
<!-- l. 954 --><p class='noindent'>It is known that computing the volume of a
<!-- l. 954 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>V</mi> </math>-polytope
(or H-polytope) is #P-hard, see <span class='cite'>[<a href='#Xdf-tccvp-88'>DF88</a>]</span> and <span class='cite'>[<a href='#Xk-cpvc-93'>Kha93</a>]</span>. There are theoretically efficient randomized
algorithms to approximate the volume of a convex body <span class='cite'>[<a href='#Xls-rwcbi-93'>LS93</a>]</span> but no implementation seems to be
available.
</p><!-- l. 960 --><p class='indent'>   There is a comparative study <span class='cite'>[<a href='#Xbef-cevcm-00'>BEF00</a>]</span> of various volume computation algorithms for convex
polytopes. It indicates that there is no single algorithm that works well for many different types of
polytopes. For “near” simple polytopes, triangulation-based algorithms are more efficient. For “near”
simplicial polytopes, sign-decomposition-based algorithms are better. See the paper for the
justification of these claims.
</p><!-- l. 971 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>3   </span> <a id='x1-270003'></a>Voronoi Diagram and Delaunay Triangulation</h3>
<!-- l. 973 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.1   </span> <a id='x1-280003.1'></a>What is cell complex? What is triangulation?</h4>
<!-- l. 976 --><p class='noindent'>A <span class='cmti-12'>cell complex </span>or simply <span class='cmti-12'>complex </span>in <!-- l. 977 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
is a set <!-- l. 977 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>K</mi></math> of convex
polyhedra (called <span class='cmti-12'>cells</span>) in <!-- l. 978 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
satisfying two conditions: (1) Every face of a cell is a cell (i.e. in
<!-- l. 979 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>K</mi></math>), and
(2) If <!-- l. 979 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
and <!-- l. 979 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>P</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
are cells, then their intersection is a common face of both. A <span class='cmti-12'>simplicial complex </span>is a cell complex
whose cells are all simplices.
</p><!-- l. 984 --><p class='indent'>   The <span class='cmti-12'>body </span><!-- l. 984 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mo class='MathClass-rel'>|</mo><mi>K</mi><mo class='MathClass-rel'>|</mo></math> of a
complex <!-- l. 984 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>K</mi></math> is the union of
all cells. When a subset <!-- l. 985 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
of <!-- l. 985 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is the body of a
simplicial complex <!-- l. 985 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>K</mi></math>,
then <!-- l. 986 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>K</mi></math> is said to be
a <span class='cmti-12'>triangulation </span>of <!-- l. 986 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>.
For a finite set <!-- l. 987 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>
of points in <!-- l. 987 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>, a
<span class='cmti-12'>triangulation of </span><!-- l. 987 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> is a
simplicial complex <!-- l. 988 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>K</mi></math>
with <!-- l. 988 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mo class='MathClass-rel'>|</mo><mi>K</mi><mo class='MathClass-rel'>|</mo> <mo class='MathClass-rel'>=</mo> <mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>.
                                                                                           
                                                                                           
</p><!-- l. 990 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.2   </span> <a id='x1-290003.2'></a>What is Voronoi diagram in <!-- l. 990 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?</h4>
<!-- l. 992 --><p class='noindent'>See also <a href='#x1-300003.3'>3.3<!-- tex4ht:ref: voro:dela_def  --></a>.
</p><!-- l. 994 --><p class='indent'>   Given a set <!-- l. 994 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> of
<!-- l. 994 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> distinct points in
<!-- l. 994 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>, Voronoi diagram
is the partition of <!-- l. 995 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
into <!-- l. 995 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> polyhedral
regions <!-- l. 996 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>vo</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
(<!-- l. 996 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></math>). Each region
<!-- l. 996 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>vo</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>, called the <span class='cmti-12'>Voronoi cell</span>
of <!-- l. 997 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math>, is defined as the
set of points in <!-- l. 998 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> which
are closer to <!-- l. 999 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math> than to
any other points in <!-- l. 999 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>,
or more precisely, </p><table class='equation-star'><tr><td>
<!-- l. 1000 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                     <mi mathvariant='italic'>vo</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup><mo class='MathClass-rel'>|</mo><mi mathvariant='italic'>dist</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi><mo class='MathClass-punc'>,</mo><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>≤</mo> <mi mathvariant='italic'>dist</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi><mo class='MathClass-punc'>,</mo><mi>q</mi></mrow><mo class='MathClass-close'>)</mo></mrow><mspace width='1em' class='quad'></mspace><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>q</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi> <mo class='MathClass-bin'>-</mo> <mi>p</mi></mrow><mo class='MathClass-close'>}</mo></mrow><mo class='MathClass-punc'>,</mo>
</math></td></tr></table>
<!-- l. 1003 --><p class='indent'>   where <!-- l. 1003 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>dist</mi></math>
is the Euclidean distance function. (One can use different distance functions to define various
variations of Voronoi diagrams, but we do not discuss them here.)
</p>
<div class='center'>
<!-- l. 1009 --><p class='noindent'>
</p><!-- l. 1010 --><p class='noindent'><img height='113' alt='PIC' width='113' src='Figures/vtest_fig_vo.png' /></p></div>
<!-- l. 1013 --><p class='indent'>   The set of all Voronoi cells and their faces forms a cell complex. The vertices of this complex are called
the <span class='cmti-12'>Voronoi vertices</span>, and the extreme rays (i.e. unbounded edges) are the <span class='cmti-12'>Voronoi rays</span>. For each point
<!-- l. 1016 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>, the <span class='cmti-12'>nearest
                                                                                           
                                                                                           
</span><span class='cmti-12'>neighbor set </span><!-- l. 1017 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>nb</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi><mo class='MathClass-punc'>,</mo><mi>v</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
of <!-- l. 1017 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math> in
<!-- l. 1017 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> is the set of
points <!-- l. 1017 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi> <mo class='MathClass-bin'>-</mo> <mi>v</mi></math> which
are closest to <!-- l. 1018 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math>
in Euclidean distance. Alternatively, one can define a point
<!-- l. 1019 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> to be a <span class='cmti-12'>Voronoi
</span><span class='cmti-12'>vertex </span>of <!-- l. 1020 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> if
<!-- l. 1020 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>nb</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi><mo class='MathClass-punc'>,</mo><mi>v</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> is
maximal over all nearest neighbor sets.
</p><!-- l. 1023 --><p class='indent'>   In order to compute the Voronoi diagram, the following construction is very important. For each
point <!-- l. 1024 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math> in
<!-- l. 1024 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>, consider the hyperplane
tangent to the paraboloid in <!-- l. 1025 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>
at <!-- l. 1025 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math>:
<!-- l. 1026 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>x</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>=</mo> <msubsup><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>+</mo> <mo class='MathClass-rel'>⋯</mo> <mo class='MathClass-bin'>+</mo> <msubsup><mrow><mi>x</mi></mrow><mrow>
<mi>d</mi></mrow><mrow><mn>2</mn></mrow></msubsup></math>. This hyperplane
is represented by <!-- l. 1027 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>h</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 1028 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                           <munderover accentunder='false' accent='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><msubsup><mrow><mi>p</mi></mrow><mrow>
<mi>j</mi></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>-</mo><munderover accentunder='false' accent='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><mn>2</mn><msub><mrow><mi>p</mi></mrow><mrow>
<mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>=</mo> <mn>0</mn><mo class='MathClass-punc'>.</mo>
</math></td></tr></table>
<!-- l. 1031 --><p class='indent'>   By replacing the equality with inequality <!-- l. 1031 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'> <mo class='MathClass-rel'>≥</mo></math>
above for each point <!-- l. 1031 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math>, we obtain
the system of <!-- l. 1032 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> inequalities,
which we denote by <!-- l. 1033 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi> <mo class='MathClass-bin'>-</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math>.
The polyhedron <!-- l. 1033 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
in <!-- l. 1033 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math> of all solutions
<!-- l. 1034 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi></math> to the system of
inequalities is a lifting of the Voronoi diagram to one higher dimensional space. In other words, by projecting
the polyhedron <!-- l. 1036 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
onto the original <!-- l. 1036 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
space, we obtain the Voronoi diagram in the sense that the projection of each facet of
<!-- l. 1037 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> associated with
<!-- l. 1038 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></math> is exactly the voronoi
cell <!-- l. 1038 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>vo</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>. The vertices and
the extreme rays of <!-- l. 1039 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>
                                                                                           
                                                                                           
project exactly to the Voronoi vertices and the rays, respectively.
</p>
<div class='center'>
<!-- l. 1043 --><p class='noindent'>
</p><!-- l. 1044 --><p class='noindent'><img height='113' alt='PIC' width='113' src='Figures/vtest_fig_vo3d.png' /></p></div>
<!-- l. 1047 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.3   </span> <a id='x1-300003.3'></a>What is the Delaunay triangulation in
<!-- l. 1047 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>?
</h4>
<!-- l. 1050 --><p class='noindent'>See also <a href='#x1-290003.2'>3.2<!-- tex4ht:ref: voro:def  --></a>, <a href='#x1-280003.1'>3.1<!-- tex4ht:ref: voronoi:complex  --></a>.
</p><!-- l. 1052 --><p class='indent'>   Let <!-- l. 1052 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> be a set
of <!-- l. 1052 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> points in
<!-- l. 1052 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>. The convex hull
<!-- l. 1053 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi mathvariant='italic'>nb</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi><mo class='MathClass-punc'>,</mo><mi>v</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow></math> of the nearest neighbor set of
a Voronoi vertex <!-- l. 1054 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math> is called the
Delaunay cell of <!-- l. 1054 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math>. The Delaunay
complex (or triangulation) of <!-- l. 1055 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> is
a partition of the convex hull <!-- l. 1056 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
into the Delaunay cells of Voronoi vertices together with their faces.
</p>
<div class='center'>
<!-- l. 1061 --><p class='noindent'>
</p><!-- l. 1062 --><p class='noindent'><img height='113' alt='PIC' width='113' src='Figures/vtest_draw_vode.png' /></p></div>
<!-- l. 1065 --><p class='indent'>   The Delaunay complex is not in general a triangulation but becomes a
triangulation when the input points are in <span class='cmti-12'>general position </span>(or <span class='cmti-12'>nondegenerate</span>), i.e. no
<!-- l. 1068 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>2</mn></math>
points are cospherical or equivalently there is no point
<!-- l. 1069 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> whose nearest neighbor
set has more than <!-- l. 1069 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></math>
elements.
</p><!-- l. 1071 --><p class='indent'>   The Delaunay complex is dual to the Voronoi diagram <a href='#x1-290003.2'>3.2<!-- tex4ht:ref: voro:def  --></a> in the sense that there is a natural
bijection between the two complexes which reverses the face inclusions.
                                                                                           
                                                                                           
</p><!-- l. 1075 --><p class='indent'>   There is a direct way to represent the Delaunay complex, just like the Voronoi diagram <a href='#x1-290003.2'>3.2<!-- tex4ht:ref: voro:def  --></a>. In fact, it uses the
same paraboloid in <!-- l. 1077 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>:
<!-- l. 1077 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>x</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>=</mo> <msubsup><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>+</mo> <mo class='MathClass-rel'>⋯</mo> <mo class='MathClass-bin'>+</mo> <msubsup><mrow><mi>x</mi></mrow><mrow>
<mi>d</mi></mrow><mrow><mn>2</mn></mrow></msubsup></math>. Let
<!-- l. 1078 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <msubsup><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>+</mo> <mo class='MathClass-rel'>⋯</mo> <mo class='MathClass-bin'>+</mo> <msubsup><mrow><mi>x</mi></mrow><mrow>
<mi>d</mi></mrow><mrow><mn>2</mn></mrow></msubsup></math>, and
let <!-- l. 1078 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi><mo class='MathClass-punc'>,</mo><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math> for
<!-- l. 1079 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></math>. Then the so-called lower
hull of the lifted points <!-- l. 1080 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-punc'>:</mo><mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-punc'>:</mo> <mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math>
represents the Delaunay complex. More precisely, let </p><table class='equation-star'><tr><td>
<!-- l. 1082 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                               <mi>P</mi> <mo class='MathClass-rel'>=</mo> <mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-bin'>+</mo> <mi mathvariant='italic'>nonneg</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow>
</math></td></tr></table>
<!-- l. 1085 --><p class='indent'>   where <!-- l. 1085 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>e</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math> is the unit
vector in <!-- l. 1085 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math> whose last
component is <!-- l. 1085 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>1</mn></math>. Thus
<!-- l. 1086 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> is the unbounded convex
polyhedron consisting of <!-- l. 1087 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover></mrow><mo class='MathClass-close'>)</mo></mrow></math>
and any nonnegative shifts by the “upper” direction
<!-- l. 1088 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>r</mi></math>.
The nontrivial claim is that the the boundary complex of
<!-- l. 1089 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> projects to the Delaunay
complex: any facet of <!-- l. 1090 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> which is not
parallel to the vertical direction <!-- l. 1091 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>r</mi></math>
is a Delaunay cell once its last coordinate is ignored, and any Delaunay cell is represented this
way.
</p><!-- l. 1095 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.4   </span> <a id='x1-310003.4'></a>Computing the Delaunay complex and the Voronoi diagram. What does it mean and how
to do it with available software?</h4>
<!-- l. 1098 --><p class='noindent'>Let <!-- l. 1098 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math> be a
given set of <!-- l. 1098 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>
points in <!-- l. 1098 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>.
Computing the Voronoi diagram normally means to generate the set
<!-- l. 1100 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>V</mi> <mi>o</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
of Voronoi vertices, and computing the Delaunay complex is essentially the
                                                                                           
                                                                                           
same thing. Once the Voronoi vertices are generated, the nearest neighbor sets
<!-- l. 1102 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>nb</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi><mo class='MathClass-punc'>,</mo><mi>v</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> for all Voronoi
vertices <!-- l. 1103 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>v</mi></math>
can be easily computed, and in fact most of the algorithms for generating the Voronoi vertices
computes the nearest neighbor sets as well at the same time.
</p><!-- l. 1107 --><p class='indent'>   The complexity of computing the Voronoi diagram is not well understood in general. For example,
there is no known algorithm that runs polynomial in the size of input and output. For the much easier
nondegenerate case, there is an algorithm, known as the reverse search algorithm, which runs in time
<!-- l. 1112 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi mathvariant='italic'>nd</mi><mo class='MathClass-rel'>|</mo><mi>V</mi> <mi>o</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-rel'>|</mo></mrow><mo class='MathClass-close'>)</mo></mrow></math>. When the dimension
is fixed (in particular <!-- l. 1113 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>=</mo> <mn>2</mn></math>),
one can analyse complexities of various-type algorithms in terms of the input size. In the plane, there are
<!-- l. 1114 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>n</mi><mi class='qopname'> log</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --> <mi>n</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math> algorithms that is
optimal, and for fixed <!-- l. 1116 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
there is an incremental <!-- l. 1116 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mrow><mo class='MathClass-open'>⌈</mo><mrow><mi>d</mi><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow><mo class='MathClass-close'>⌉</mo></mrow></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>
algorithm, see <span class='cite'>[<a href='#Xgo-hbdcg-97'>Ge97</a>, Chapter 20]</span>.
</p><!-- l. 1119 --><p class='indent'>   How large is the number <!-- l. 1119 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mo class='MathClass-rel'>|</mo><mi>V</mi> <mi>o</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>S</mi></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-rel'>|</mo></math>
of output? The tight upper bound was given in <span class='cite'>[<a href='#Xs-eubnf-91'>Sei91</a>]</span> which is
<!-- l. 1121 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>n</mi></mrow><mrow><mfenced open='⌊' close='⌋' separators=''><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow></mfenced></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>. While this
bound may be a far over-estimate of expected behavior, the number of output typically grows exponentially
in <!-- l. 1124 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> and
<!-- l. 1124 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>, and
thus the computation itself is expected to be heavy. Therefore, one must take a caution to do the
Delaunay/Voronoi computation. In fact,
      </p><div class='quote'>
      <!-- l. 1127 --><p class='noindent'>I know quite a few people who tried to use Voronoi diagram computation codes in
      order to accomplish a much simpler task.</p></div>
<!-- l. 1131 --><p class='noindent'>It is not only a waste of time and computer resources, but it often leads to a prohibitively hard
computation, while an appropriate use of mathematical techniques resolves the problem
instantly.
</p><!-- l. 1136 --><p class='indent'>   For example, the following computations are much simpler and should be solved via linear
programming techniques in Section <a href='#x1-390004'>4<!-- tex4ht:ref: Sec:LP  --></a>: </p>
      <ul class='itemize1'>
      <li class='itemize'>For given two points <!-- l. 1139 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi></math>
      and <!-- l. 1139 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>q</mi></math>
      in <!-- l. 1139 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>,
      check whether their Voronoi cells are adjacent in the Voronoi diagram, see <a href='#x1-330003.5'>3.5<!-- tex4ht:ref: voro:adjacency  --></a>.
      </li>
      <li class='itemize'>For any given point <!-- l. 1141 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>,
      find a Delaunay cell containing <!-- l. 1142 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math>,
      see <a href='#x1-360003.7'>3.7<!-- tex4ht:ref: dela:cellbylp  --></a>.
      </li></ul>
                                                                                           
                                                                                           
<!-- l. 1146 --><p class='indent'>   The most natural way to compute the Voronoi diagram is by computing the vertices and the extreme rays of
the polyhedron in <!-- l. 1148 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>
given in <a href='#x1-290003.2'>3.2<!-- tex4ht:ref: voro:def  --></a>. By ignoring the last component of each vertices we obtain the Voronoi vertices.
</p><!-- l. 1152 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.4.1   </span> <a id='x1-320003.4.1'></a>Sample session with cddlib</h5>
<!-- l. 1156 --><p class='noindent'><span class='cmr-10x-x-109'>Consider a simple two dimensional case: </span><!-- l. 1156 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>=</mo> <mn>2</mn></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1156 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi> <mo class='MathClass-rel'>=</mo> <mn>6</mn></math> <span class='cmr-10x-x-109'>and</span>
<!-- l. 1157 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mn>0</mn><mo class='MathClass-punc'>,</mo><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mn>1</mn><mo class='MathClass-punc'>,</mo><mn>2</mn></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mn>4</mn><mo class='MathClass-punc'>,</mo><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mn>0</mn><mo class='MathClass-punc'>,</mo><mn>4</mn></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mrow><mo class='MathClass-open'>(</mo><mrow><mn>4</mn><mo class='MathClass-punc'>,</mo><mn>4</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>}</mo></mrow></math><span class='cmr-10x-x-109'>. In principle the session
</span><span class='cmr-10x-x-109'>below will work in any </span><!-- l. 1158 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
<span class='cmr-10x-x-109'>and </span><!-- l. 1158 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math><span class='cmr-10x-x-109'>,
</span><span class='cmr-10x-x-109'>although the computation time depends heavily on the size.</span>
</p><!-- l. 1161 --><p class='indent'>   <span class='cmr-10x-x-109'>The first step is to write down the system of linear inequalities in</span>
<!-- l. 1162 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math> <span class='cmr-10x-x-109'>variables as explained
</span><span class='cmr-10x-x-109'>in </span><a href='#x1-290003.2'><span class='cmr-10x-x-109'>3.2</span><!-- tex4ht:ref: voro:def  --></a><span class='cmr-10x-x-109'>: for each </span><!-- l. 1163 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></math><span class='cmr-10x-x-109'>,</span>
</p><table class='equation-star'><tr><td>
<!-- l. 1164 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                            <munderover accentunder='false' accent='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><msubsup><mrow><mi>p</mi></mrow><mrow>
<mi>j</mi></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>-</mo><munderover accentunder='false' accent='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><mn>2</mn><msub><mrow><mi>p</mi></mrow><mrow>
<mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mo class='MathClass-punc'>.</mo>
</math></td></tr></table>
<!-- l. 1167 --><p class='indent'>   <span class='cmr-10x-x-109'>For our example, we have:</span> </p><table class='equation-star'><tr><td>
<!-- l. 1168 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
 <mtable equalrows='false' style='' align='axis' columnlines='none none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='right'> <mn>0</mn></mtd><mtd class='array' columnalign='right'>      </mtd><mtd class='array' columnalign='right'>      </mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='right'> <mn>5</mn></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>4</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='right'> <mn>5</mn></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>4</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='right'><mn>16</mn></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>8</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd class='array' columnalign='right'>      </mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='right'><mn>16</mn></mtd><mtd class='array' columnalign='right'>      </mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>8</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mtd>
</mtr>  <mtr><mtd class='array' columnalign='right'><mn>32</mn></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>8</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>-</mo> <mn>8</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd class='array' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mtd></mtr><!-- rrrr --></mtable>
</math></td></tr></table>
                                                                                           
                                                                                           
<!-- l. 1180 --><p class='indent'>   <span class='cmr-10x-x-109'>We denote by </span><!-- l. 1180 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> <span class='cmr-10x-x-109'>the
</span><span class='cmr-10x-x-109'>polyhedron of all solutions </span><!-- l. 1180 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>
<span class='cmr-10x-x-109'>satisfying the inequalities above. Now we prepare an input file for cddlib. The file must be in </span><span class='cmti-10x-x-109'>polyhedra
</span><span class='cmr-10x-x-109'>format and for the system above, it is rather straightforward since it essentially codes the coefficients of the
</span><span class='cmr-10x-x-109'>system.</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-1' class='verbatim'>
* filename: vtest_vo.ine
 <br />H-representation
 <br />begin
 <br /> 6   4   integer
 <br />  0  0  0  1
 <br />  5 -4 -2  1
 <br />  5 -2 -4  1
 <br /> 16 -8  0  1
 <br /> 16  0 -8  1
 <br /> 32 -8 -8  1
 <br />end
 <br />incidence
 <br />input_adjacency
</div>
<!-- l. 1201 --><p class='nopar'>
</p><!-- l. 1203 --><p class='noindent'><span class='cmr-10x-x-109'>The last two lines “incidence” and “input_adjacency” are options for the (old) standalone code cdd+. They
</span><span class='cmr-10x-x-109'>are not necessary for scdd.c (a sample code for cddlib). The executables of scdd.c, namely, scdd
</span><span class='cmr-10x-x-109'>(floating-point) or scdd_gmp (gmp exact rational) computes the second (generator) representation
</span><span class='cmr-10x-x-109'>vtest_vo.ext of the polyhedron and output four files vtest_vo.icd, vtest_ecd, vo.vtest_vo.iad, and
</span><span class='cmr-10x-x-109'>vtest_vo.ead.</span>
</p><!-- l. 1211 --><p class='indent'>   <span class='cmr-10x-x-109'>Now, by running scdd.c with commands:</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-2' class='verbatim'>
% scdd_gmp vtest_vo.ine
</div>
<!-- l. 1215 --><p class='nopar'> <span class='cmr-10x-x-109'>or</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-3' class='verbatim'>
% scdd vtest_vo.ine
</div>
<!-- l. 1219 --><p class='nopar'> <span class='cmr-10x-x-109'>we obtain the five files mentioned above. Among them the most important for our purpose are the following
</span><span class='cmr-10x-x-109'>three, vtest_vo.ext (all extreme points and rays), vtest_vo.iad (adjacency of facet inequalities) and
</span><span class='cmr-10x-x-109'>vtest_vo.ecd (incidence of extreme points/rays and inequalities). Note that scdd_gmp runs in rational exact
</span><span class='cmr-10x-x-109'>arithmetic and scdd runs in floating-point arithmetic. scdd runs much faster than scdd_gmp but it may not
</span><span class='cmr-10x-x-109'>give a correct answer.</span>
</p><!-- l. 1229 --><p class='indent'>   <span class='cmr-10x-x-109'>The file vtest_vo.ext would be something like the following:</span>
</p><!-- l. 1231 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-4' class='verbatim'>
ext_file: Generators
 <br />V-representation
 <br />begin
 <br /> 10 4 rational
 <br /> 0 -1 0 0
 <br /> 1 -3/2 2 0
 <br /> 1 5/6 5/6 0
 <br /> 1 2 -3/2 0
 <br /> 0 0 -1 0
 <br /> 1 27/10 27/10 56/5
 <br /> 1 15/4 2 14
 <br /> 0 1 0 8
 <br /> 0 0 1 8
 <br /> 1 2 15/4 14
 <br />end
</div>
<!-- l. 1248 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1251 --><p class='indent'>   <span class='cmr-10x-x-109'>The output contains all the vertices and extreme rays of the (unbounded) polyhedron</span>
<!-- l. 1252 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> <span class='cmr-10x-x-109'>in</span>
<!-- l. 1252 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mn>3</mn></mrow></msup></math><span class='cmr-10x-x-109'>.
</span><span class='cmr-10x-x-109'>Namely each row starting with “1” represents a vertex. So the second row</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-5' class='verbatim'>
  1 -3/2 2 0
</div>
<!-- l. 1255 --><p class='nopar'> <span class='cmr-10x-x-109'>represents the vertex </span><!-- l. 1256 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mo class='MathClass-bin'>-</mo><mn>3</mn><mo class='MathClass-bin'>∕</mo><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>.
</span><span class='cmr-10x-x-109'>Each row starting with “0” represents an extreme ray, e.g. the first row</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-6' class='verbatim'>
  0 -1 0 0 
</div>
<!-- l. 1258 --><p class='nopar'> <span class='cmr-10x-x-109'>represents the ray </span><!-- l. 1259 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mo class='MathClass-bin'>-</mo><mn>1</mn><mo class='MathClass-punc'>,</mo><mn>0</mn><mo class='MathClass-punc'>,</mo><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>.</span>
</p><!-- l. 1261 --><p class='indent'>   <span class='cmr-10x-x-109'>By ignoring the last components, we obtain the set of six Voronoi vertices</span>
<!-- l. 1262 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mo class='MathClass-bin'>-</mo><mn>3</mn><mo class='MathClass-bin'>∕</mo><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>2</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1262 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>5</mn><mo class='MathClass-bin'>∕</mo><mn>6</mn><mo class='MathClass-punc'>,</mo><mn>5</mn><mo class='MathClass-bin'>∕</mo><mn>6</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1262 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>2</mn><mo class='MathClass-punc'>,</mo><mo class='MathClass-bin'>-</mo><mn>3</mn><mo class='MathClass-bin'>∕</mo><mn>2</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1262 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>27</mn><mo class='MathClass-bin'>∕</mo><mn>10</mn><mo class='MathClass-punc'>,</mo><mn>27</mn><mo class='MathClass-bin'>∕</mo><mn>10</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1263 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>15</mn><mo class='MathClass-bin'>∕</mo><mn>4</mn><mo class='MathClass-punc'>,</mo><mn>2</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math> <span class='cmr-10x-x-109'>and</span>
<!-- l. 1263 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>15</mn><mo class='MathClass-bin'>∕</mo><mn>4</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math> <span class='cmr-10x-x-109'>and four
</span><span class='cmr-10x-x-109'>Voronoi rays </span><!-- l. 1264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mo class='MathClass-bin'>-</mo><mn>1</mn><mo class='MathClass-punc'>,</mo><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>0</mn><mo class='MathClass-punc'>,</mo><mo class='MathClass-bin'>-</mo><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>1</mn><mo class='MathClass-punc'>,</mo><mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math> <span class='cmr-10x-x-109'>and</span>
<!-- l. 1264 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>0</mn><mo class='MathClass-punc'>,</mo><mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>.</span>
</p><!-- l. 1266 --><p class='indent'>   <span class='cmr-10x-x-109'>The incidence file vtest_vo.ecd file:</span>
</p><!-- l. 1268 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-7' class='verbatim'>
ecd_file: Incidence of generators and inequalities
 <br />begin
 <br />  10    7
 <br /> 1 3 : 1 5 7
 <br /> 2 3 : 1 3 5
 <br /> 3 3 : 1 2 3
 <br /> 4 3 : 1 2 4
 <br /> 5 3 : 1 4 7
 <br /> 6 3 : 2 3 6
 <br /> 7 3 : 2 4 6
 <br /> 8 3 : 4 6 7
 <br /> 9 3 : 5 6 7
 <br /> 10 3 : 3 5 6
 <br />end
</div>
<!-- l. 1284 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1287 --><p class='indent'>   <span class='cmr-10x-x-109'>Each row corresponds to the same row in vtest_vo.ext file. For example, the second data</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-8' class='verbatim'>
 2 3 : 1 3 5
</div>
<!-- l. 1289 --><p class='nopar'> <span class='cmr-10x-x-109'>says the second data in vtest_vo.ext file:</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-9' class='verbatim'>
 1 -3/2 2 0
</div>
<!-- l. 1292 --><p class='nopar'> <span class='cmr-10x-x-109'>is a voronoi vertex whose nearest neighbor set is</span>
<!-- l. 1294 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>{</mo><mrow><msup><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc'>,</mo><msup><mrow><mi>p</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-punc'>,</mo><msup><mrow><mi>p</mi></mrow><mrow><mn>5</mn></mrow></msup></mrow><mo class='MathClass-close'>}</mo></mrow></math><span class='cmr-10x-x-109'>. Also,
</span><span class='cmr-10x-x-109'>this set corresponds to a Delaunay cell. Similarly, the first row</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-10' class='verbatim'>
 1 3 : 1 5 7
</div>
<!-- l. 1297 --><p class='nopar'> <span class='cmr-10x-x-109'>indicates the ray (the first output in vtest_vo.ext file)</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-11' class='verbatim'>
  0 -1 0 0 
</div>
<!-- l. 1299 --><p class='nopar'> <span class='cmr-10x-x-109'>is determined by 1, 5 and 7th halfspaces. The 7th halfspace is an artificial one corresponding to the infinity.
</span><span class='cmr-10x-x-109'>So this ray is determined by the input points 1 and 5 and going to infinity.</span>
</p><!-- l. 1304 --><p class='indent'>   <span class='cmr-10x-x-109'>Thus, the index sets (triples, in this case) not containing the infinity</span>
<!-- l. 1305 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>7</mn></math> <span class='cmr-10x-x-109'>determine all Delaunay
</span><span class='cmr-10x-x-109'>cells, and those containing </span><!-- l. 1306 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>7</mn></math>
<span class='cmr-10x-x-109'>correspond to the Voronoi rays.</span>
</p><!-- l. 1308 --><p class='indent'>   <span class='cmr-10x-x-109'>Finally, look at the vtest_vo.iad file:</span>
</p><!-- l. 1311 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-12' class='verbatim'>
iad_file: Adjacency of inequalities
 <br />begin
 <br />  7    7
 <br /> 1 -5 : 1 6
 <br /> 2 -4 : 2 5 7
 <br /> 3 -4 : 3 4 7
 <br /> 4 -4 : 3 4 5
 <br /> 5 -4 : 2 4 5
 <br /> 6 -5 : 1 6
 <br /> 7 -4 : 2 3 7
 <br />end
</div>
<!-- l. 1324 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1327 --><p class='noindent'><span class='cmr-10x-x-109'>This file contains the graph structure (adjacency list) of the Delaunay complex and equivalently the
</span><span class='cmr-10x-x-109'>adjacency of Voronoi cells in the Voronoi diagram.</span>
</p>
<div class='center'>
<!-- l. 1333 --><p class='noindent'>
</p><!-- l. 1334 --><p class='noindent'><img height='113' alt='PIC' width='113' src='Figures/vtest_draw_vode.png' /></p></div>
<!-- l. 1337 --><p class='noindent'><span class='cmr-10x-x-109'>For example, the first row</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-13' class='verbatim'>
  1 -5 : 1 6
</div>
<!-- l. 1341 --><p class='nopar'> <span class='cmr-10x-x-109'>says that the first Voronoi cell is adjacent to </span><!-- l. 1342 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>5</mn></math>
<span class='cmr-10x-x-109'>cells. The row is equivalent to</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-14' class='verbatim'>
  1 5 : 2 3 4 5 7
</div>
<!-- l. 1346 --><p class='nopar'> <span class='cmr-10x-x-109'>Notice that the cddlib lists the non-neighbors whenever the number of non-neighbors is smaller than that of neighbors.
</span><span class='cmr-10x-x-109'>Thus, the negative </span><!-- l. 1350 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'> <mo class='MathClass-bin'>-</mo> <mn>5</mn></math>
<span class='cmr-10x-x-109'>indicates that the list is non-neighbors.</span>
</p><!-- l. 1352 --><p class='indent'>   <span class='cmr-10x-x-109'>In the language of the Delaunay complex, the first line in this file says the point</span>
<!-- l. 1353 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msup></math> <span class='cmr-10x-x-109'>is adjacent
</span><span class='cmr-10x-x-109'>to </span><!-- l. 1353 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>5</mn></math>
<span class='cmr-10x-x-109'>neighbors </span><!-- l. 1354 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>2</mn></mrow></msup></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1354 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>3</mn></mrow></msup></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1354 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>4</mn></mrow></msup></math><span class='cmr-10x-x-109'>,</span>
<!-- l. 1354 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>5</mn></mrow></msup></math> <span class='cmr-10x-x-109'>and</span>
<!-- l. 1354 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>7</mn></mrow></msup></math><span class='cmr-10x-x-109'>. Here, the
</span><span class='cmr-10x-x-109'>point </span><!-- l. 1355 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>7</mn></mrow></msup></math> <span class='cmr-10x-x-109'>is
</span><span class='cmr-10x-x-109'>the artificial infinity point which is considered adjacent to any input point whose Voronoi cell is
</span><span class='cmr-10x-x-109'>unbounded.</span>
</p><!-- l. 1359 --><p class='indent'>   <span class='cmr-10x-x-109'>As we remarked before, this graph information can be computed much more efficiently by linear
</span><span class='cmr-10x-x-109'>programming. See </span><a href='#x1-330003.5'><span class='cmr-10x-x-109'>3.5</span><!-- tex4ht:ref: voro:adjacency  --></a><span class='cmr-10x-x-109'>.</span>
</p><!-- l. 1365 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.5   </span> <a id='x1-330003.5'></a>Is it possible to compute only the adjacencies of Voronoi cells in the Voronoi diagram
efficiently?</h4>
<!-- l. 1368 --><p class='noindent'>Yes, it can be done very efficiently by linear programming (LP), and very importantly this can be
done for very large scale problems, with practically no bounds on the size with an efficient LP
solver.
</p><!-- l. 1372 --><p class='indent'>   The method is simple. The lifting technique we described in <a href='#x1-290003.2'>3.2<!-- tex4ht:ref: voro:def  --></a> immediately gives the idea. Recall that the Voronoi
diagram of a set <!-- l. 1375 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>
of <!-- l. 1375 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math> points in
<!-- l. 1375 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> is the projection of the
following <!-- l. 1376 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math>-polyhedron
to <!-- l. 1377 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math> space of
the first <!-- l. 1377 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>
components. </p><table class='equation-star'><tr><td>
                                                                                           
                                                                                           
<!-- l. 1378 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
               <mi>P</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup><mspace width='0.28em' class='thickpace'></mspace><mo class='MathClass-rel'>|</mo><mspace width='0.28em' class='thickpace'></mspace><munderover accentunder='false' accent='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><msubsup><mrow><mi>p</mi></mrow><mrow>
<mi>j</mi></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>-</mo><munderover accentunder='false' accent='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><mn>2</mn><msub><mrow><mi>p</mi></mrow><mrow>
<mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mspace width='1em' class='quad'></mspace><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></mrow><mo class='MathClass-close'>}</mo></mrow><mo class='MathClass-punc'>.</mo>
</math></td></tr></table>
<!-- l. 1382 --><p class='indent'>   For simplicity, denote it as </p><table class='equation-star'><tr><td>
<!-- l. 1383 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                                <mi>P</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup><mspace width='0.28em' class='thickpace'></mspace><mo class='MathClass-rel'>|</mo><mspace width='0.28em' class='thickpace'></mspace><mi>b</mi> <mo class='MathClass-bin'>-</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></mrow><mo class='MathClass-close'>}</mo></mrow><mo class='MathClass-punc'>,</mo>
</math></td></tr></table>
<!-- l. 1386 --><p class='indent'>   where <!-- l. 1386 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>A</mi></math>
is a given <!-- l. 1386 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi> <mo class='MathClass-bin'>×</mo> <mrow><mo class='MathClass-open'>(</mo><mrow><mi>d</mi> <mo class='MathClass-bin'>+</mo> <mn>1</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math>
matrix and <!-- l. 1386 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi></math>
is a <!-- l. 1386 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>-vector.
Now for each <!-- l. 1387 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>n</mi></math>,
consider the <!-- l. 1387 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>i</mi></math>th
facet <!-- l. 1387 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
of <!-- l. 1387 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>:
</p><!-- tex4ht:inline --><!-- l. 1391 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                       <mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup><mspace width='0.28em' class='thickpace'></mspace><mo class='MathClass-rel'>|</mo><mspace width='0.28em' class='thickpace'></mspace><mi>b</mi> <mo class='MathClass-bin'>-</mo> <mi>A</mi><mspace width='0.28em' class='thickpace'></mspace><mi>x</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mstyle class='mbox'><mtext> and </mtext></mstyle><msub><mrow><mi>b</mi></mrow><mrow>
<mi>i</mi></mrow></msub> <mo class='MathClass-bin'>-</mo> <msub><mrow><mi>A</mi></mrow><mrow><mi>i</mi></mrow></msub><mspace width='0.28em' class='thickpace'></mspace><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mn>0</mn></mrow><mo class='MathClass-close'>}</mo></mrow><mo class='MathClass-punc'>,</mo></mtd>                       <mtd class='align-even'><mspace width='2em'></mspace></mtd>                       <mtd class='align-label' columnalign='right'><mstyle id='x1-33001r9' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(9)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 1392 --><p class='noindent'>Two facets <!-- l. 1392 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub></math> and
<!-- l. 1392 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>j</mi></mrow></msub></math> are called <span class='cmti-12'>adjacent </span>if the
intersection <!-- l. 1393 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin'>∩</mo> <msub><mrow><mi>F</mi></mrow><mrow><mi>j</mi></mrow></msub></math> is a facet of
both, i.e. has dimension <!-- l. 1394 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-bin'>-</mo> <mn>2</mn></math>.
An equivalent definition is: they are <span class='cmti-12'>adjacent  </span>if (*) the facet
                                                                                           
                                                                                           
<!-- l. 1395 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub></math> becomes larger once the
facet <!-- l. 1396 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>j</mi></mrow></msub></math> is removed from the
polyhedron, i.e. the <!-- l. 1396 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>j</mi></math>th inequality
is removed from the system <!-- l. 1397 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi> <mo class='MathClass-bin'>-</mo> <mi>A</mi><mspace width='0.28em' class='thickpace'></mspace><mi>x</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math>.
</p><!-- l. 1399 --><p class='indent'>   It is easy to see that two Voronoi cells <!-- l. 1399 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>vo</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>p</mi></mrow><mrow><mi>i</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>
and <!-- l. 1399 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi mathvariant='italic'>vo</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math> are adjacent if and only if
the corresponding facets <!-- l. 1400 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub></math> and
<!-- l. 1401 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>j</mi></mrow></msub></math> are adjacent in the polyhedron
<!-- l. 1401 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>. Now, we formulate the
following LP for any distinct <!-- l. 1403 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>i</mi></math>,
<!-- l. 1403 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>j</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo> <mn>2</mn><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>…</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mo class='MathClass-punc'>,</mo><mi>n</mi></math>:
</p><!-- l. 1405 --><p class='indent'>
</p><!-- tex4ht:inline --><!-- l. 1411 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='align' columnalign='left'>
                       <mtr><mtd class='align-odd' columnalign='right'> <mtable equalrows='false' style='' align='axis' columnlines='none none none none none none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'></mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>minimize</mtext></mstyle> </mtd><mtd class='array' columnalign='left'><mspace width='1em' class='quad'></mspace><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-punc'>:</mo><mo class='MathClass-rel'>=</mo></mtd><mtd class='array' columnalign='left'><msub><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow></msub></mtd><mtd class='array' columnalign='left'><mo class='MathClass-bin'>-</mo></mtd><mtd class='array' columnalign='left'><msub><mrow><mi>A</mi></mrow><mrow><mi>j</mi></mrow></msub></mtd><mtd class='array' columnalign='left'><mi>x</mi>     </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'></mtd><mtd class='array' columnalign='left'><mstyle class='text'><mtext>subject to</mtext></mstyle></mtd><mtd class='array' columnalign='left'>          </mtd><mtd class='array' columnalign='left'><msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup></mtd><mtd class='array' columnalign='left'><mo class='MathClass-bin'>-</mo></mtd><mtd class='array' columnalign='left'><mi>A</mi> </mtd><mtd class='array' columnalign='left'><mi>x</mi><mspace width='0.28em' class='thickpace'></mspace> <mo class='MathClass-rel'>≥</mo><mspace width='0.28em' class='thickpace'></mspace><mn>0</mn> </mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'></mtd><mtd class='array' columnalign='left'>             </mtd><mtd class='array' columnalign='left'>          </mtd><mtd class='array' columnalign='left'><msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub></mtd><mtd class='array' columnalign='left'><mo class='MathClass-bin'>-</mo></mtd><mtd class='array' columnalign='left'><msub><mrow><mi>A</mi></mrow><mrow><mi>i</mi></mrow></msub></mtd><mtd class='array' columnalign='left'><mi>x</mi><mspace width='0.28em' class='thickpace'></mspace> <mo class='MathClass-rel'>≤</mo><mspace width='0.28em' class='thickpace'></mspace><mn>0</mn><mo class='MathClass-punc'>,</mo></mtd></mtr> <!-- lllllll --></mtable>                                                                     </mtd>                       <mtd class='align-even'><mspace width='2em'></mspace></mtd>                       <mtd class='align-label' columnalign='right'><mstyle id='x1-33002r10' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(10)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 1413 --><p class='noindent'>where <!-- l. 1414 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup></math> is equal
to <!-- l. 1414 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi></math> except for
<!-- l. 1414 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>j</mi></math>th component
<!-- l. 1415 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msubsup><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow><mrow><mi>′</mi></mrow></msubsup> <mo class='MathClass-rel'>=</mo> <msub><mrow><mi>b</mi></mrow><mrow>
<mi>j</mi></mrow></msub> <mo class='MathClass-bin'>+</mo> <mn>1</mn></math>. The new
inequality system <!-- l. 1415 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-bin'>-</mo> <mi>A</mi><mspace width='0.28em' class='thickpace'></mspace><mi>x</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math>
is simply a modification of the original system obtained by relaxing the
<!-- l. 1417 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>j</mi></math>th
inequality a little bit. An important remark is, by definition (*),
<!-- l. 1418 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>j</mi></mrow></msub></math> and
<!-- l. 1418 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub></math> are adjacent if and only
if the objective value <!-- l. 1419 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
is negative at an optimum solution. Thus we formulated the Voronoi adjacency computation as an
LP problem.
</p><!-- l. 1423 --><p class='indent'>   How much do we gain by using LP for the adjacency computation, instead of computing the
whole Voronoi diagram? A lot. It is hard to exaggerate this, because the LP (<a href='#x1-33002r10'>10<!-- tex4ht:ref: eq:voro_facet_lp  --></a>) (in fact any LP) is
solvable in polynomial time, whereas the associated Voronoi computation is exponential in
<!-- l. 1428 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math> and
<!-- l. 1428 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>. Using the
standard simplex method, the time complexity of solving an LP is not polynomial, but the practical complexity
                                                                                           
                                                                                           
is roughly <!-- l. 1430 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>O</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>n</mi><msup><mrow><mi>d</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow></math>.
</p><!-- l. 1432 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.5.1   </span> <a id='x1-340003.5.1'></a>Sample session with cddlib</h5>
<!-- l. 1435 --><p class='noindent'><span class='cmr-10x-x-109'>With cddlib, a setup for computing the adjacency of Voronoi cells is quite simple. Consider the same example </span><a href='#x1-320003.4.1'><span class='cmr-10x-x-109'>3.4.1</span><!-- tex4ht:ref: voro:computation:session  --></a><span class='cmr-10x-x-109'>. For each
</span><span class='cmr-10x-x-109'>input point </span><!-- l. 1438 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>3</mn><mo class='MathClass-punc'>,</mo><mn>4</mn><mo class='MathClass-punc'>,</mo><mn>5</mn><mo class='MathClass-punc'>,</mo><mn>6</mn></math><span class='cmr-10x-x-109'>, we write the
</span><span class='cmr-10x-x-109'>inequality system for the facet </span><!-- l. 1438 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>F</mi></mrow><mrow><mi>i</mi></mrow></msub></math><span class='cmr-10x-x-109'>:</span>
</p><table class='equation-star'><tr><td>
<!-- l. 1439 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
 <mtable equalrows='false' style='' align='axis' columnlines='none' class='array' equalcolumns='false'> <mtr><mtd class='array' columnalign='left'></mtd><mtd class='array' columnalign='left'><mi>b</mi> <mo class='MathClass-bin'>-</mo> <mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mstyle class='text'><mtext> and </mtext></mstyle></mtd>
</mtr>  <mtr><mtd class='array' columnalign='left'></mtd><mtd class='array' columnalign='left'><msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin'>-</mo> <msub><mrow><mi>A</mi></mrow><mrow><mi>i</mi></mrow></msub><mi>x</mi> <mo class='MathClass-rel'>≤</mo> <mn>0</mn><mstyle class='text'><mtext>,</mtext></mstyle>    </mtd></mtr><!-- ll --></mtable>
</math></td></tr></table>
<!-- l. 1445 --><p class='indent'>   <span class='cmr-10x-x-109'>instead of writing the relaxed inequality (</span><a href='#x1-33002r10'><span class='cmr-10x-x-109'>10</span><!-- tex4ht:ref: eq:voro_facet_lp  --></a><span class='cmr-10x-x-109'>). For example, for</span>
<!-- l. 1446 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>4</mn></math><span class='cmr-10x-x-109'>, we
</span><span class='cmr-10x-x-109'>have</span>
</p><!-- l. 1448 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-15' class='verbatim'>
H-representation
 <br />begin
 <br /> 7   4   real
 <br />  0  0  0  1
 <br />  5 -4 -2  1
 <br />  5 -2 -4  1
 <br /> 16 -8  0  1
 <br /> 16  0 -8  1
 <br /> 32 -8 -8  1
 <br />-16  8  0 -1
 <br />end
 <br />facet_listing
</div>
<!-- l. 1462 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1465 --><p class='noindent'><span class='cmr-10x-x-109'>We save this as the file vtest_vof4.ine The last inequality is the negative of the forth inequality to force the
</span><span class='cmr-10x-x-109'>forth inequality to be equality.</span>
</p><!-- l. 1470 --><p class='indent'>   <span class='cmr-10x-x-109'>The old code cdd+ accepts an option called “facet_listing”. With this option, cdd+ will check which of
</span><span class='cmr-10x-x-109'>the given inequalities is redundant or not (essential), by solving the associated LP’s (</span><a href='#x1-33002r10'><span class='cmr-10x-x-109'>10</span><!-- tex4ht:ref: eq:voro_facet_lp  --></a><span class='cmr-10x-x-109'>) for each inequality</span>
<!-- l. 1474 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>j</mi></math><span class='cmr-10x-x-109'>.</span>
</p><!-- l. 1476 --><p class='indent'>   <span class='cmr-10x-x-109'>With cddlib, we can do the same test by the program redcheck.c, which is distributed in the src
</span><span class='cmr-10x-x-109'>subdirectory. This program ignores this option line, and does the redundancy removal and finds a minimal
</span><span class='cmr-10x-x-109'>representation of the polyhedron.</span>
</p><!-- l. 1481 --><p class='indent'>   <span class='cmr-10x-x-109'>By running the executable redcheck_gmp (exact gmp rational) or redcheck (floating-point)
</span><span class='cmr-10x-x-109'>by</span>
                                                                                           
                                                                                           
</p>
   <div id='verbatim-16' class='verbatim'>
% redcheck_gmp vtest_vof4.ine
</div>
<!-- l. 1485 --><p class='nopar'> <span class='cmr-10x-x-109'>we will get the output:</span>
</p><!-- l. 1488 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-17' class='verbatim'>
input file vtest_vof4.ine is open
 <br />Canonicalize the matrix.
 <br />Implicit linearity rows are: 4 7
 <br />
 <br />Redundant rows are: 3 5
 <br />
 <br />Nonredundant representation:
 <br />The new row positions are as follows (orig:new).
 <br />Each redundant row has the new number 0.
 <br />Each deleted duplicated row has a number nagative of the row that
 <br />represents its equivalence class.
 <br /> 1:2 2:3 3:0 4:1 5:0 6:4 7:0
 <br />H-representation
 <br />linearity 1  1
 <br />begin
 <br /> 4 4 rational
 <br /> 16 -8 0 1
 <br /> 0 0 0 1
 <br /> 5 -4 -2 1
 <br /> 32 -8 -8 1
 <br />end
</div>
<!-- l. 1511 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1514 --><p class='indent'>   <span class='cmr-10x-x-109'>First of all, it recognizes that the </span><!-- l. 1514 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>4</mn></math><span class='cmr-10x-x-109'>th
</span><span class='cmr-10x-x-109'>and the </span><!-- l. 1514 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>7</mn></math><span class='cmr-10x-x-109'>th
</span><span class='cmr-10x-x-109'>row are implicit equations and should be written as an equation. Then, the redundant rows are recognized as</span>
<!-- l. 1516 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>3</mn></math><span class='cmr-10x-x-109'>rd and</span>
<!-- l. 1516 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>5</mn></math><span class='cmr-10x-x-109'>th. Thus, we can
</span><span class='cmr-10x-x-109'>consider the set </span><!-- l. 1517 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>{</mo><mrow><mn>1</mn><mo class='MathClass-punc'>,</mo><mn>2</mn><mo class='MathClass-punc'>,</mo><mn>6</mn></mrow><mo class='MathClass-close'>}</mo></mrow></math>
<span class='cmr-10x-x-109'>as the indices of essential constraints, or equivalently the indices of Voronoi cells adjacent to the</span>
<!-- l. 1518 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>4</mn></math><span class='cmr-10x-x-109'>th cell.
</span><span class='cmr-10x-x-109'>Of course, this adjacency coincides with the adjacency of input points in the Delaunay triangulation. See
</span><span class='cmr-10x-x-109'>the figure below.</span>
</p>
<div class='center'>
<!-- l. 1524 --><p class='noindent'>
</p><!-- l. 1525 --><p class='noindent'><img height='113' alt='PIC' width='113' src='Figures/vtest_draw_de.png' /></p></div>
                                                                                           
                                                                                           
<!-- l. 1532 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.6   </span> <a id='x1-350003.6'></a>Is it possible to compute only the edges of the Delaunay complex (triangulation)
?</h4>
<!-- l. 1534 --><p class='noindent'>This is essentially the same question as computing the adjacencies of Voronoi cells, see
<a href='#x1-330003.5'>3.5<!-- tex4ht:ref: voro:adjacency  --></a>.
</p><!-- l. 1538 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.7   </span> <a id='x1-360003.7'></a>Is it possible to determine the Delaunay cell containing a given point efficiently?</h4>
<!-- l. 1541 --><p class='noindent'>Yes, it is possible to find the nearest point set associated with the Delaunay cell containing a given point
<!-- l. 1542 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math>. As we
discussed in Section <a href='#x1-300003.3'>3.3<!-- tex4ht:ref: voro:dela_def  --></a>, the Delaunay complex can be represented by the convex hull of appropriately lifted
points in <!-- l. 1545 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>,
and the non-vertical facets coincide with the Delaunay cells once they are projected to the
original space. Thus the problem of determining the Delaunay cell containing a given point
<!-- l. 1548 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math> can be
reduced to finding the first facet of a polyhedron “shoot” by a ray.
</p><!-- l. 1551 --><p class='indent'>   To be more precise, let <!-- l. 1552 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <msubsup><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin'>+</mo> <mo class='MathClass-rel'>⋯</mo> <mo class='MathClass-bin'>+</mo> <msubsup><mrow><mi>x</mi></mrow><mrow>
<mi>d</mi></mrow><mrow><mn>2</mn></mrow></msubsup></math>,
and let <!-- l. 1552 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi><mo class='MathClass-punc'>,</mo><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math> for
<!-- l. 1553 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></math>. Then the lower
hull <!-- l. 1553 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> of the
lifted points <!-- l. 1554 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-punc'>:</mo><mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>{</mo><mrow><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-punc'>:</mo> <mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi></mrow><mo class='MathClass-close'>}</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 1555 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                               <mi>P</mi> <mo class='MathClass-rel'>=</mo> <mi mathvariant='italic'>conv</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-bin'>+</mo> <mi mathvariant='italic'>nonneg</mi><mrow><mo class='MathClass-open'>(</mo><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow>
</math></td></tr></table>
<!-- l. 1558 --><p class='indent'>   represents the Delaunay complex. Here <!-- l. 1559 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>e</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>
is the unit vetor in <!-- l. 1559 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math> whose
last component is <!-- l. 1559 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>1</mn></math>.
For any vector <!-- l. 1560 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>ỹ</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>
and <!-- l. 1560 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-rel'>∈</mo> <mi>R</mi></math>, let
<!-- l. 1561 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>ỹ</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≥</mo><mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow>
<mn>0</mn></mrow></msub></math> denote a general inequality
of a variable vector <!-- l. 1562 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>.
For such an inequality to represent a valid inequality of
                                                                                           
                                                                                           
<!-- l. 1563 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math> (see Section <a href='#x1-50002.2'>2.2<!-- tex4ht:ref: polytope:faces  --></a>), it must
be satisfied by all points in <!-- l. 1564 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover></math>:
</p><table class='equation'><tr><td> <a id='x1-36001r11'></a>
<!-- l. 1565 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'><msup><mrow>
                                  <mi>ỹ</mi></mrow><mrow><mi>T</mi> </mrow></msup><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-rel'>≥</mo><mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow>
<mn>0</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-rel'>∈</mo><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover><mo class='MathClass-punc'>,</mo>
</math></td><td class='eq-no'>(11)</td></tr></table>
<!-- l. 1568 --><p class='indent'>   and by any points shifted vertically upwards, i.e. </p><table class='equation-star'><tr><td>
<!-- l. 1569 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'><msup><mrow>
                     <mi>ỹ</mi></mrow><mrow><mi>T</mi> </mrow></msup><mrow><mo class='MathClass-open'>(</mo><mrow><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-bin'>+</mo> <mi>α</mi><msup><mrow><mi>e</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>≥</mo><mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow>
<mn>0</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mover accent='true'><mrow><mi>p</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-rel'>∈</mo><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>̃</mo></mover><mstyle class='text'><mtext> and any </mtext></mstyle><mi>α</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mo class='MathClass-punc'>.</mo>
</math></td></tr></table>
<!-- l. 1573 --><p class='noindent'>Under the first inequality (<a href='#x1-36001r11'>11<!-- tex4ht:ref: voro:delfacet1  --></a>), the last inequality is equivalent to </p><table class='equation'><tr><td> <a id='x1-36002r12'></a>
<!-- l. 1576 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'><msub><mrow>
                                        <mi>ỹ</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mo class='MathClass-punc'>.</mo>
</math></td><td class='eq-no'>(12)</td></tr></table>
<!-- l. 1580 --><p class='noindent'>Now every Delaunay cell is a projection of a non-vertical facet of
<!-- l. 1582 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>P</mi></math>. We are thus looking
for an inequality <!-- l. 1583 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>ỹ</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>≥</mo><mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow>
<mn>0</mn></mrow></msub></math>
satisfying (<a href='#x1-36001r11'>11<!-- tex4ht:ref: voro:delfacet1  --></a>), (<a href='#x1-36002r12'>12<!-- tex4ht:ref: voro:delfacet2  --></a>) and <!-- l. 1584 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>y</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-rel'>≠</mo><mn>0</mn></math>.
By scaling with <!-- l. 1585 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>ỹ</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>&gt;</mo> <mn>0</mn></math>,
we may assume <!-- l. 1585 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>ỹ</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>=</mo> <mn>1</mn></math>.
For a given point <!-- l. 1586 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math>,
let <!-- l. 1586 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-rel'>=</mo> <msup><mrow><mrow><mo class='MathClass-open'>(</mo><mrow><mi>c</mi><mo class='MathClass-punc'>,</mo> <mn>0</mn></mrow><mo class='MathClass-close'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup></math>, and let
                                                                                           
                                                                                           
<!-- l. 1587 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>L</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>λ</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-rel'>=</mo> <mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>̃</mo></mover> <mo class='MathClass-bin'>+</mo> <mi>λ</mi><mspace width='0.28em' class='thickpace'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msup></math>,
<!-- l. 1587 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>λ</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math>. Determining the
Delaunay cell containing <!-- l. 1588 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math>
is equivalent to finding the last inequality “hit” by the halfline
<!-- l. 1590 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>L</mi></math>. More
precisely, it is to find a non-vertical facet inequality such that the intersecion point of the corresponding
hyperplane <!-- l. 1592 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>{</mo><mrow><mi>x</mi> <mo class='MathClass-punc'>:</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>=</mo> <mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow>
<mn>0</mn></mrow></msub></mrow><mo class='MathClass-close'>}</mo></mrow></math> and
the half line <!-- l. 1592 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>L</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>λ</mi></mrow><mo class='MathClass-close'>)</mo></mrow><mo class='MathClass-punc'>,</mo><mi>λ</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math>
is highest possible.
</p><!-- l. 1595 --><p class='indent'>   By substituting <!-- l. 1595 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>L</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>λ</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
for <!-- l. 1595 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>x</mi></math> in
<!-- l. 1595 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>y</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi> <mo class='MathClass-rel'>=</mo> <mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow>
<mn>0</mn></mrow></msub></math> with
<!-- l. 1596 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>ỹ</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel'>=</mo> <mn>1</mn></math>, we
obtain </p><table class='equation-star'><tr><td>
<!-- l. 1597 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML' class='equation'>
                                      <mi>λ</mi> <mo class='MathClass-rel'>=</mo> <mo class='MathClass-bin'>-</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-bin'>-</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>c</mi><mo class='MathClass-punc'>,</mo>
</math></td></tr></table>
<!-- l. 1600 --><p class='indent'>   where <!-- l. 1600 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>y</mi></math> denotes
the vector <!-- l. 1600 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>ỹ</mi></math> without
the last coordinate <!-- l. 1601 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msub><mrow><mi>ỹ</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin'>+</mo><mn>1</mn></mrow></msub></math>.
The LP formulation is therefore:
</p><!-- tex4ht:inline --><!-- l. 1607 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='alignat' columnalign='left'>
                       <mtr><mtd class='align-odd' columnalign='right'></mtd>                       <mtd class='align-even'><mstyle class='text'><mtext>minimize</mtext></mstyle><mspace width='2em'></mspace></mtd>                        <mtd class='align-odd' columnalign='right'><mi>z</mi> <mo class='MathClass-punc'>:</mo><mo class='MathClass-rel'>=</mo></mtd>                       <mtd class='align-even'><mspace width='2em'></mspace></mtd>                           <mtd class='align-odd' columnalign='right'><msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-bin'>+</mo></mtd>                          <mtd class='align-even'><msup><mrow><mi>y</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>c</mi><mspace width='2em'></mspace></mtd>                                                                                                                                                            <mtd class='align-label' columnalign='right'>                      <mstyle id='x1-36003r13' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(13)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
                       </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                       <mtd class='align-even'><mstyle class='text'><mtext>subject to</mtext></mstyle><mspace width='2em'></mspace></mtd>                       <mtd class='align-odd' columnalign='right'></mtd>                           <mtd class='align-even'><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>p</mi></mrow><mo class='MathClass-close'>)</mo></mrow><mspace width='2em'></mspace></mtd>                       <mtd class='align-odd' columnalign='right'> <mo class='MathClass-bin'>+</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-bin'>+</mo></mtd>                       <mtd class='align-even'><msup><mrow><mi>y</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>p</mi> <mo class='MathClass-rel'>≥</mo> <mn>0</mn><mstyle class='text'><mtext> for all </mtext></mstyle><mi>p</mi> <mo class='MathClass-rel'>∈</mo> <mi>S</mi><mo class='MathClass-punc'>.</mo><mspace width='2em'></mspace></mtd>                       <mtd class='align-label' columnalign='right'></mtd>                       <mtd class='align-label'><mspace width='2em'></mspace></mtd>                       <mtd class='align-label' columnalign='right'></mtd>                       <mtd class='align-label'><mspace width='2em'></mspace></mtd>                       <mtd class='align-label' columnalign='right'></mtd>                       <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
                                                                                           
                                                                                           
<!-- l. 1608 --><p class='noindent'>While an optimal solution <!-- l. 1608 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-punc'>,</mo><mi>y</mi></mrow><mo class='MathClass-close'>)</mo></mrow></math>
to this LP may not determine any facet in general, the simplex method always returns an optimal
basic solution which determines a facet inequality in this case. The Delaunay cell containing
<!-- l. 1611 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math> is the one determined
by the set of points in <!-- l. 1612 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>
whose corresponding inequalities are satisfied by equality at the optimal solution. If the LP solution
is not degenerate, the dual variables that are positive at the dual optimal solution coincides with the
former set.
</p><!-- l. 1617 --><p class='indent'>   It is important to note that the above LP might be unbounded. If it is unbounded, it can be easily shown that
<!-- l. 1618 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math> is not in any Delaunay cell,
i.e., not in the convex hull of <!-- l. 1619 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>.
A certificate of unboundedness actually induces a hyperplane strongly separating
<!-- l. 1621 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi></math> from
<!-- l. 1621 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>S</mi></math>.
(why?)
</p><!-- l. 1623 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead'><span class='titlemark'>3.7.1   </span> <a id='x1-370003.7.1'></a>Sample session with cddlib</h5>
<!-- l. 1628 --><p class='noindent'><span class='cmr-10x-x-109'>With cddlib (scdd.c) and any reasonable LP code, the only necessary step should be
</span><span class='cmr-10x-x-109'>to prepare the LP file for determination of the Delaunay cell containing a given point</span>
<!-- l. 1630 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi> <mo class='MathClass-rel'>∈</mo> <msup><mrow><mi>R</mi></mrow><mrow><mi>d</mi></mrow></msup></math><span class='cmr-10x-x-109'>.
</span><span class='cmr-10x-x-109'>Consider the same example </span><a href='#x1-320003.4.1'><span class='cmr-10x-x-109'>3.4.1</span><!-- tex4ht:ref: voro:computation:session  --></a><span class='cmr-10x-x-109'>.</span>
</p><!-- l. 1633 --><p class='indent'>   <span class='cmr-10x-x-109'>For a given point </span><!-- l. 1633 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>(</mo><mrow><mn>3</mn><mo class='MathClass-punc'>,</mo><mn>2</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>,
</span><span class='cmr-10x-x-109'>the LP (</span><a href='#x1-36003r13'><span class='cmr-10x-x-109'>13</span><!-- tex4ht:ref: eq:dela_celllp  --></a><span class='cmr-10x-x-109'>) file for scdd or scdd_gmp is</span>
</p><!-- l. 1636 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-18' class='verbatim'>
H-representation
 <br />begin
 <br />  6  4  rational
 <br />  0  1  0  0
 <br />  5  1  2  1
 <br />  5  1  1  2
 <br /> 16  1  4  0
 <br /> 16  1  0  4
 <br /> 32  1  4  4
 <br />end
 <br />minimize
 <br />  0  1  3  2
</div>
<!-- l. 1650 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1653 --><p class='noindent'><span class='cmr-10x-x-109'>The solution by scdd_gmp is:</span>
</p><!-- l. 1656 --><p class='noindent'>___________________________________________________________________________________________
                                                                                           
                                                                                           
</p>
   <div id='verbatim-19' class='verbatim'>
* #constraints = 6
 <br />* #variables   = 3
 <br />* Algorithm: dual simplex algorithm
 <br />* minimization is chosen
 <br />* Objective function is
 <br /> 0 + 1 X[  1] + 3 X[  2] + 2 X[  3]
 <br />* LP status: a dual pair (x,y) of optimal solutions found.
 <br />begin
 <br />  primal_solution
 <br />    1 :  14
 <br />    2 :  -15/2
 <br />    3 :  -4
 <br />  dual_solution
 <br />    2 :  -1/2
 <br />    4 :  -1/8
 <br />    6 :  -3/8
 <br />  optimal_value :  -33/2
 <br />end
</div>
<!-- l. 1676 --><p class='nopar'> ___________________________________________________________________________________
</p><!-- l. 1679 --><p class='indent'>   <span class='cmr-10x-x-109'>Therefore, the facet inequality is </span><!-- l. 1679 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>14</mn> <mo class='MathClass-bin'>-</mo> <mn>15</mn><mo class='MathClass-bin'>∕</mo><mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin'>-</mo> <mn>4</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel'>≥</mo> <mn>0</mn></math><span class='cmr-10x-x-109'>, and
</span><span class='cmr-10x-x-109'>the dual solution indicates that the points </span><!-- l. 1680 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>p</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc'>,</mo><msup><mrow><mi>p</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-punc'>,</mo><msup><mrow><mi>p</mi></mrow><mrow><mn>6</mn></mrow></msup></math>
<span class='cmr-10x-x-109'>determine the Delaunay cell which contains </span><!-- l. 1681 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mrow><mo class='MathClass-open'>(</mo><mrow><mn>3</mn><mo class='MathClass-punc'>,</mo><mn>2</mn></mrow><mo class='MathClass-close'>)</mo></mrow></math><span class='cmr-10x-x-109'>.</span>
</p><!-- l. 1689 --><p class='noindent'>
</p>
   <h4 class='subsectionHead'><span class='titlemark'>3.8   </span> <a id='x1-380003.8'></a>What is the best upper bound of the numbers of simplices in the Delaunay
triangulation?</h4>
<!-- l. 1691 --><p class='noindent'>See <a href='#x1-310003.4'>3.4<!-- tex4ht:ref: voro:computation  --></a>.
</p><!-- l. 1695 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>4   </span> <a id='x1-390004'></a>Linear Programming</h3>
<!-- l. 1697 --><p class='noindent'>
</p>
                                                                                           
                                                                                           
   <h4 class='subsectionHead'><span class='titlemark'>4.1   </span> <a id='x1-400004.1'></a>What is LP?</h4>
<!-- l. 1699 --><p class='noindent'>A linear programming (abbreviated by LP) is to find a maximizer or minimizer of a linear function
subject to linear inequality constraints. More precisely,
</p><!-- l. 1703 --><p class='indent'>
</p><!-- tex4ht:inline --><!-- l. 1708 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='alignat' columnalign='left'>
                  <mtr><mtd class='align-odd' columnalign='right'></mtd>                  <mtd class='align-even'><mstyle class='text'><mtext>maximize</mtext></mstyle><mspace width='2em'></mspace></mtd>                   <mtd class='align-odd' columnalign='right'><mspace width='1em' class='quad'></mspace><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-punc'>:</mo><mo class='MathClass-rel'>=</mo></mtd>                  <mtd class='align-even'><munderover accentunder='false' accent='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><msub><mrow><mi>c</mi></mrow><mrow>
<mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub><mspace width='2em'></mspace></mtd>                                                                                                  <mtd class='align-label' columnalign='right'>                      <mstyle id='x1-40001r14' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(14)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
                  </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                  <mtd class='align-even'><mstyle class='text'><mtext>subject to</mtext></mstyle><mspace width='2em'></mspace></mtd>                  <mtd class='align-odd' columnalign='right'></mtd>                          <mtd class='align-even'><munderover accentunder='false' accent='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel'>=</mo><mn>1</mn></mrow><mrow><mi>d</mi></mrow></munderover><msub><mrow><mi>a</mi></mrow><mrow>
<mi mathvariant='italic'>ij</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel'>≤</mo> <msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub><mstyle class='text'><mtext> for all </mtext></mstyle><mi>i</mi> <mo class='MathClass-rel'>=</mo> <mn>1</mn><mo class='MathClass-punc'>,</mo> <mn>2</mn><mo class='MathClass-punc'>,</mo><mo>…</mo><mo class='MathClass-punc'>,</mo><mi>m</mi><mo class='MathClass-punc'>,</mo><mspace width='2em'></mspace></mtd>                                                                        <mtd class='align-label' columnalign='right'>                <mstyle id='x1-40002r15' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(15)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
                  </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                  <mtd class='align-even'><mspace width='2em'></mspace></mtd>                            <mtd class='align-odd' columnalign='right'></mtd>                          <mtd class='align-even'><mspace width='2em'></mspace></mtd>                                                        <mtd class='align-label' columnalign='right'>
   </mtd></mtr></mtable></math>
where <!-- l. 1709 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>A</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>[</mo><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub></mrow><mo class='MathClass-close'>]</mo></mrow></math> is a
given rational <!-- l. 1709 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi> <mo class='MathClass-bin'>×</mo> <mi>d</mi></math>
matrix, <!-- l. 1710 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>c</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>[</mo><mrow><msub><mrow><mi>c</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow><mo class='MathClass-close'>]</mo></mrow></math> and
<!-- l. 1710 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>b</mi> <mo class='MathClass-rel'>=</mo> <mrow><mo class='MathClass-open'>[</mo><mrow><msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub></mrow><mo class='MathClass-close'>]</mo></mrow></math> are given
rational <!-- l. 1710 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>- and
<!-- l. 1710 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>n</mi></math>-vector.
We often write an LP in matrix form:
<!-- tex4ht:inline --><!-- l. 1717 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><mtable class='alignat' columnalign='left'>
                                <mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'><mstyle class='text'><mtext>maximize</mtext></mstyle><mspace width='2em'></mspace></mtd>                                 <mtd class='align-odd' columnalign='right'><mspace width='1em' class='quad'></mspace><mi>f</mi><mrow><mo class='MathClass-open'>(</mo><mrow><mi>x</mi></mrow><mo class='MathClass-close'>)</mo></mrow> <mo class='MathClass-punc'>:</mo><mo class='MathClass-rel'>=</mo></mtd>                                <mtd class='align-even'><msup><mrow><mi>c</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>x</mi><mspace width='2em'></mspace></mtd>                                                                                                                                    <mtd class='align-label' columnalign='right'>                                <mstyle id='x1-40003r16' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(16)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
                                </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'><mstyle class='text'><mtext>subject to</mtext></mstyle><mspace width='2em'></mspace></mtd>                                <mtd class='align-odd' columnalign='right'></mtd>                                       <mtd class='align-even'><mi mathvariant='italic'>Ax</mi> <mo class='MathClass-rel'>≤</mo> <mi>b</mi><mo class='MathClass-punc'>.</mo><mspace width='2em'></mspace></mtd>                                                                                                                                <mtd class='align-label' columnalign='right'>                                <mstyle id='x1-40004r17' class='label'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(17)</mtext></mstyle><mspace width='0.33em' class='nbsp'></mspace>
                                </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'><mspace width='2em'></mspace></mtd>                                          <mtd class='align-odd' columnalign='right'></mtd>                                       <mtd class='align-even'><mspace width='2em'></mspace></mtd>                                        <mtd class='align-label' columnalign='right'>
   </mtd></mtr></mtable></math>
                                                                                           
                                                                                           
<!-- l. 1719 --><p class='noindent'>Theoretically every rational LP is solvable in polynomial time by both the ellipsoid method of
Khachian (see <span class='cite'>[<a href='#Xk-palp-79'>Kha79</a>, <a href='#Xs-tlip-86'>Sch86</a>]</span>) various interior point methods (see <span class='cite'>[<a href='#Xk-nptal-84'>Kar84</a>, <a href='#Xrtv-talpip-97'>RTV97</a>]</span>). The
well-known simplex method of Dantzig (see <span class='cite'>[<a href='#Xd-lpe-63'>Dan63</a>, <a href='#Xc-lp-83'>Chv83</a>]</span>) has no known polynomial variants. In
practice, very large LPs can be solved efficiently by both the simplex method and interior-point
methods. For example, it is very easy on a standard unix station to solve an LP with
<!-- l. 1729 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi> <mo class='MathClass-rel'>=</mo> <mn>100</mn></math> and
<!-- l. 1729 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>m</mi> <mo class='MathClass-rel'>=</mo> <mn>100</mn><mo class='MathClass-punc'>,</mo> <mn>000</mn></math>, while
the vertex enumeration/convex hull computation of the same size is simply intractable. There are
many commercial codes and public codes available. See the LP FAQ <span class='cite'>[<a href='#Xfg-lpfaq'>FG</a>]</span>. Two excellent
classical books on LP are Chvatal’s textbook <span class='cite'>[<a href='#Xc-lp-83'>Chv83</a>]</span> and Schrijver’s “researcher’s bible”
<span class='cite'>[<a href='#Xs-tlip-86'>Sch86</a>]</span>.
</p><!-- l. 1736 --><p class='indent'>   There is a new textbook on LP theory and Optimization <span class='cite'>[<a href='#Xf-io-20'>Fuk20a</a>]</span> which explains the duality theory
and the finite pivoting theory quite differently from the classical textbooks. One essential difference
comes from a rather elementary fact that the classical numbering of the dual variables is not
mathematically sound, see <span class='cite'>[<a href='#Xf-io-20'>Fuk20a</a>, Chap 1–4]</span>. Once the dual variables are properly renumbered,
one can see that the LP duality is a property of the orthogonal dual pairs of vector subspaces of
<!-- l. 1743 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><msup><mrow><mi>R</mi></mrow><mrow><mi>n</mi></mrow></msup></math>.
</p><!-- l. 1747 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>5   </span> <a id='x1-410005'></a>Polyhedral Computation Codes</h3>
      <ul class='itemize1'>
      <li class='itemize'>cddlib, cdd and cdd+ <span class='cite'>[<a href='#Xf-cddhome'>Fuka</a>]</span> (C and C++ implementations of the double description method
      <span class='cite'>[<a href='#Xmrtt-ddm-53'>MRTT53</a>]</span>).
           <div class='quote'>
           <!-- l. 1752 --><p class='noindent'>Comments: Runs on both floating and exact arithmetic. Efficient for highly
           degenerate  cases.  The  exact  versions  are  much  slower.  It  can  remove
           redundancies from input data using a built-in LP code. cddlib is a C-library
           with  basic  polyhedral  conversion  functions  and  LP  solvers.  cddlib  can  be
           compiled with both GMP rational (mpq) and floating point arithmetic. A new
           arithmetic (with an arithmetic library) can be added to cddlib.</p></div>
      </li>
      <li class='itemize'>lrs and lrslib <span class='cite'>[<a href='#Xa-lrshome-01'>Avi</a>]</span> (C implementation of the reverse search algorithm <span class='cite'>[<a href='#Xaf-pachv-92'>AF92</a>]</span>). A parallel
      version prs was developed by A. Marzetta, see <span class='cite'>[<a href='#Xbmfn-psbza-96'>BMFN96</a>]</span>.
           <div class='quote'>
           <!-- l. 1765 --><p class='noindent'>Comments: Exact arithmetic only, efficient for nondegenerate cases. Uses a
           little memory and perhaps the only available code which can deal with problems
                                                                                           
                                                                                           
           in high dimensions, say, over <!-- l. 1766 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>20</mn></math>.
           There is a parallel implementation mplrs that uses the MPI library.</p></div>
      </li>
      <li class='itemize'>pd <span class='cite'>[<a href='#Xm-pdcip-97'>Mar97</a>]</span> (C implementation of the primal-dual algorithm <span class='cite'>[<a href='#Xbfm-pdmvf-97'>BFM97</a>]</span>).
           <div class='quote'>
           <!-- l. 1773 --><p class='noindent'>Comments: Exact arithmetic only, efficient for dually nondegenerate cases.</p></div>
      </li>
      <li class='itemize'>qhull <span class='cite'>[<a href='#Xbdh-qach-96'>BDH96</a>, <a href='#Xbdh-qach-03'>BDH03</a>]</span> (C implementation of the beneath-beyond method, see
      <span class='cite'>[<a href='#Xe-acg-87'>Ede87</a>, <a href='#Xm-cg-94'>Mul94</a>]</span>, which is a sort of dual of the double description method).
           <div class='quote'>
           <!-- l. 1780 --><p class='noindent'>Comments: Floating arithmetic only but handles numerical problems well.
           Highly efficient for nondegenerate cases. User can call it as a C-libary.</p></div>
      </li>
      <li class='itemize'>porta <span class='cite'>[<a href='#Xcl-porta-97'>CL97</a>]</span> (C implementation of the Fourier-Motzkin elimination method <span class='cite'>[<a href='#Xz-lop-94'>Zie94</a>]</span>).
      <!-- l. 1788 --><p class='noindent'>
           </p><div class='quote'>
           <!-- l. 1789 --><p class='noindent'>Comments: Efficient for combinatorial (e.g. 0-1) polytopes. Guarantees correct
           numerical  results  as  long  as  double  precision  integer  arithmetic  does  not
           overflow. It can list all integer solutions in a polytope.</p></div>
      </li>
      <li class='itemize'>polymake <span class='cite'>[<a href='#Xgj-pm-99'>GJ99</a>]</span> (computational environment for the algorithmic treatment of polytopes and
      polyhedra).
      <!-- l. 1799 --><p class='noindent'>
           </p><div class='quote'>
           <!-- l. 1800 --><p class='noindent'>One can generate convex polytopes and do various computations with convex
           polyhedra.  It  uses  cddlib/porta/lrslib  for  representation  conversions.  It  is
           extendable by writing own ”rules” to generate new structures/data associated
           with polyhedra.</p></div>
      </li>
      <li class='itemize'>PPL <span class='cite'>[<a href='#Xb-pplhome'>Bag04</a>]</span> (C++ implementation of the double description method <span class='cite'>[<a href='#Xmrtt-ddm-53'>MRTT53</a>]</span>).
           <div class='quote'>
           <!-- l. 1810 --><p class='noindent'>Comments: A modern efficient implementation. Exact arithmetic only.</p></div>
                                                                                           
                                                                                           
      </li>
      <li class='itemize'>zeRone <span class='cite'>[<a href='#Xl-zvefzo-99'>Lb99</a>]</span> (C implementation of the backtrack vertex enumeration algorithm for 0-1
      H-polytopes <span class='cite'>[<a href='#Xbl-vs01ps-98'>BL98</a>]</span>.
      <!-- l. 1817 --><p class='noindent'>
           </p><div class='quote'>
           <!-- l. 1818 --><p class='noindent'>Comments: In general, the straightforward backtrack algorithm for the vertex
           enumeration problem must solve NP-complete decision problems, as it was
           shown in <span class='cite'>[<a href='#Xflm-abala-97'>FLM97</a>]</span>. The situation is different for 0-1 polytopes and the problem
           is strongly polynomially solvable. The code can generate all 0-1 points in a
           general H-polytope. It relies on the commercial LP solver CPLEX.</p></div>
      </li>
      <li class='itemize'>Pointers to many other programs in geometric computations are stored in <span class='cite'>[<a href='#Xa-dcg'>Ame</a>, <a href='#Xe-cgp'>Eri</a>]</span>.
      </li>
      <li class='itemize'>For linear programming, one should check the Linear Programming FAQ at <span class='cite'>[<a href='#Xfg-lpfaq'>FG</a>]</span>. It lists both
      public (open source) and commercial codes.
      </li></ul>
<!-- l. 1837 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>6   </span> <a id='x1-420006'></a>Acknowledgements</h3>
<!-- l. 1838 --><p class='noindent'>The author expresses his sincere thanks to Dr. Vera Rosta who read an earlier version of FAQ
carefully, found numerous errors and provided with many helpful suggestions.
</p><!-- l. 2 --><p class='noindent'>
</p>
   <h3 class='likesectionHead'><a id='x1-430006'></a>References</h3>
<!-- l. 2 --><p class='noindent'>
           </p><div class='thebibliography'>
           <p class='bibitem'><span class='biblabel'>
 [ABS97]  <span class='bibsp'>   </span></span><a id='Xabs-hgach-97'></a>D. Avis, D. Bremner, and R. Seidel.  How good are convex hull algorithms.
           <span class='cmti-12'>Computational Geometry: Theory and Applications</span>, 7:265–302, 1997.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [AF92]    <span class='bibsp'>   </span></span><a id='Xaf-pachv-92'></a>D. Avis and K. Fukuda.  A pivoting algorithm for convex hulls and vertex
           enumeration of arrangements and polyhedra. <span class='cmti-12'>Discrete Comput. Geom.</span>, 8:295–313,
           1992.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [AF96]    <span class='bibsp'>   </span></span><a id='Xaf-rse-96'></a>D. Avis and K. Fukuda.  Reverse search for enumeration.  <span class='cmti-12'>Discrete Applied
           </span><span class='cmti-12'>Mathematics</span>, 65:21–46, 1996.
                                                                                           
                                                                                           
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Ame]    <span class='bibsp'>   </span></span><a id='Xa-dcg'></a>N. Amenta.                   Directory       of       computational       geometry.
           <a href='http://www.geom.uiuc.edu/software/cglist/' class='url'><span class='cmtt-12'>http://www.geom.uiuc.edu/software/cglist/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Avi]      <span class='bibsp'>   </span></span><a id='Xa-lrshome-01'></a>D. Avis. <span class='cmti-12'>lrs homepage</span>. <a href='http://cgm.cs.mcgill.ca/~avis/C/lrs.html' class='url'><span class='cmtt-12'>http://cgm.cs.mcgill.ca/~avis/C/lrs.html</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Bag04]   <span class='bibsp'>   </span></span><a id='Xb-pplhome'></a>R. Bagnara.              Parma     polyhedra     library     homepage,     2004.
           <a href='http://www.cs.unipr.it/ppl/' class='url'><span class='cmtt-12'>http://www.cs.unipr.it/ppl/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BDH96]  <span class='bibsp'>   </span></span><a id='Xbdh-qach-96'></a>C. Bradford Barber, David P. Dobkin, and Hannu Huhdanpaa. The quickhull
           algorithm for convex hulls.  <span class='cmti-12'>ACM Trans. Math. Softw.</span>, 22(4):469–483, December
           1996.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BDH03]  <span class='bibsp'>   </span></span><a id='Xbdh-qach-03'></a>C.B. Barber, D.P. Dobkin, and H. Huhdanpaa.  <span class='cmti-12'>qhull, Version 2003.1</span>, 2003.
           <a href='http://www.qhull.org/' class='url'><span class='cmtt-12'>http://www.qhull.org/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BEF00]  <span class='bibsp'>   </span></span><a id='Xbef-cevcm-00'></a>B. Beler, A. Enge, and K. Fukuda. Exact volume computation for convex
           polytopes: A practical study. In G. Kalai and G. M. Ziegler, editors, <span class='cmti-12'>Polytopes –
           </span><span class='cmti-12'>Combinatorics and Computation</span>, DMV-Seminar 29, pages 131–154. Birkhuser,
           2000.
           <a href='http://www.cs.mcgill.ca/~fukuda/download/paper/volcomp980807.pdf' class='url'><span class='cmtt-12'>http://www.cs.mcgill.ca/~fukuda/download/paper/volcomp980807.pdf</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BFM97]  <span class='bibsp'>   </span></span><a id='Xbfm-pdmvf-97'></a>D. Bremner, K. Fukuda, and A. Marzetta.  Primal-dual methods for vertex
           and facet enumeration. In <span class='cmti-12'>Proc. 13th Annu. ACM Sympos. Comput. Geom.</span>, pages
           49–56, 1997.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BL98]    <span class='bibsp'>   </span></span><a id='Xbl-vs01ps-98'></a>M.R.    Bussieck    and    M.E.    Lbbecke.         The    vertex    set    of    a
           <!-- l. 63 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>0</mn><mo class='MathClass-bin'>∕</mo><mn>1</mn></math>-polytope
           is strongly p-enumerable. <span class='cmti-12'>Computational Geometry</span>, 11:103–109, 1998.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BMFN96]<span class='bibsp'>   </span></span><a id='Xbmfn-psbza-96'></a>A. Brngger,  A. Marzetta,  K. Fukuda,  and  J. Nievergelt.    The  parallel
           search bench zram and its applications. Technical report, ETH Zurich, May 1996.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BMT85] <span class='bibsp'>   </span></span><a id='Xbmt-sacb-85'></a>C. Buchta, J. Mller, and R. F. Tichy. Stochastical approximation of convex
           bodies. <span class='cmti-12'>Math. Ann.</span>, 271(2):225–235, 1985.
                                                                                           
                                                                                           
           </p>
           <p class='bibitem'><span class='biblabel'>
 [BP00]    <span class='bibsp'>   </span></span><a id='Xbp-01pmf-00'></a>I. Brny  and  A. Pr.   0-1  polytopes  with  many  facets.   Manuscript,
           Rnyi  Institute  of  Mathematics,  Hungarian  Academy  of  Sciences,  2000.
           <a href='http://www.renyi.hu/~barany/' class='url'><span class='cmtt-12'>http://www.renyi.hu/~barany/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [CCH53]  <span class='bibsp'>   </span></span><a id='Xcch-itlp-53'></a>A. Charnes,  W.W.  Cooper,  and  A. Henderson.   <span class='cmti-12'>An introduction to linear
           </span><span class='cmti-12'>programming</span>. John Wiley &amp; Sons, Inc., 1953.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Cha93]   <span class='bibsp'>   </span></span><a id='Xc-ochaa-93'></a>B. Chazelle. An optimal convex hull algorithm in any fixed dimension. <span class='cmti-12'>Discrete
           </span><span class='cmti-12'>Comput. Geom.</span>, 10:377–409, 1993.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Chv83]   <span class='bibsp'>   </span></span><a id='Xc-lp-83'></a>V. Chvatal. <span class='cmti-12'>Linear Programming</span>. W.H.Freeman and Company, 1983.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [CK70]   <span class='bibsp'>   </span></span><a id='Xck-acp-70'></a>D.R. Chand and S.S. Kapur.  An algorithms for convex polytopes.  <span class='cmti-12'>J. Assoc.
           </span><span class='cmti-12'>Comput. Mach.</span>, 17:78–86, 1970.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [CL97]    <span class='bibsp'>   </span></span><a id='Xcl-porta-97'></a>T. Christof                                  and                                  A. Lbel.
           PORTA: Polyhedron representation transformation algorithm (ver. 1.3.1), 1997.
           <a href='http://www.zib.de/Optimization/Software/Porta/' class='url'><span class='cmtt-12'>http://www.zib.de/Optimization/Software/Porta/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Cla94]   <span class='bibsp'>   </span></span><a id='Xc-mosga-94'></a>K. L.  Clarkson.    More  output-sensitive  geometric  algorithms.    In  <span class='cmti-12'>Proc.
           </span><span class='cmti-12'>35th  Annu.  IEEE  Sympos.  Found.  Comput.  Sci.</span>,   pages   695–702,   1994.
           <a href='http://cm.bell-labs.com/who/clarkson/pubs.html' class='url'><span class='cmtt-12'>http://cm.bell-labs.com/who/clarkson/pubs.html</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Dan63]   <span class='bibsp'>   </span></span><a id='Xd-lpe-63'></a>G.B. Dantzig.   <span class='cmti-12'>Linear Programming and Extensions</span>.   Princeton University
           Press, Princeton, New Jersey, 1963.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [DF88]    <span class='bibsp'>   </span></span><a id='Xdf-tccvp-88'></a>M.E. Dyer and A.M. Frieze.  The complexity of computing the volume of a
           polyhedron. <span class='cmti-12'>SIAM J. Comput.</span>, 17:967–974, 1988.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Dye83]   <span class='bibsp'>   </span></span><a id='Xd-cvem-83'></a>M.E. Dyer. The complexity of vertex enumeration methods. <span class='cmti-12'>Math. Oper. Res.</span>,
           8:381–402, 1983.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Ede87]   <span class='bibsp'>   </span></span><a id='Xe-acg-87'></a>H. Edelsbrunner.  <span class='cmti-12'>Algorithms in Combinatorial Geometry</span>.  Springer-Verlag,
           1987.
                                                                                           
                                                                                           
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Eri]      <span class='bibsp'>   </span></span><a id='Xe-cgp'></a>J. Erickson.   Computational  geometry  pages,  list  of  software  libraries  and
           codes. <a href='http://compgeom.cs.uiuc.edu/~jeffe/compgeom/' class='url'><span class='cmtt-12'>http://compgeom.cs.uiuc.edu/~jeffe/compgeom/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [FG]      <span class='bibsp'>   </span></span><a id='Xfg-lpfaq'></a>R. Fourer and J.W. Gregory. Linear programming frequently asked questions
           (LP-FAQ).
           </p>
           <p class='bibitem'><span class='biblabel'>
 [FLL00]  <span class='bibsp'>   </span></span><a id='Xfll-ech-00'></a>K. Fukuda,  Th. M.  Liebling,  and  C. Ltolf.     Extended  convex  hull.
           In  D. Bremner,  editor,  <span class='cmti-12'>Proceedings  of  the  12th  Canadian  Conference  on
           </span><span class='cmti-12'>Computational Geometry</span>, pages 57–63, 2000.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [FLM97]  <span class='bibsp'>   </span></span><a id='Xflm-abala-97'></a>K. Fukuda, Th. M. Liebling, and F. Margot. Analysis of backtrack algorithms
           for  listing  all  vertices  and  all  faces  of  a  convex  polyhedron.   <span class='cmti-12'>Computational
           </span><span class='cmti-12'>Geometry</span>, 8:1–12, 1997.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [FO85]    <span class='bibsp'>   </span></span><a id='Xfo-ocfpsc-85'></a>R. Freund and J. Orlin. On the complexity of four polyhedral set containment
           problems. <span class='cmti-12'>Math. Programming</span>, 33:133–145, 1985.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [FR94]    <span class='bibsp'>   </span></span><a id='Xfr-cfecp-94'></a>K. Fukuda  and  V. Rosta.     Combinatorial  face  enumeration  in  convex
           polytopes. <span class='cmti-12'>Computational Geometry</span>, 4:191–198, 1994.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Fuka]    <span class='bibsp'>   </span></span><a id='Xf-cddhome'></a>K. Fukuda.
           <span class='cmti-12'>cdd, cddplus and cddlib homepage</span>.  Swiss Federal Institute of Technology, Zurich.
           <a href='http://www.inf.ethz.ch/personal/fukudak/cdd_home/index.html' class='url'><span class='cmtt-12'>http://www.inf.ethz.ch/personal/fukudak/cdd_home/index.html</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Fukb]    <span class='bibsp'>   </span></span><a id='Xf-kfhome'></a>K. Fukuda.      Komei   Fukuda’s   Homepage,   ETH   Zurich,   Switzerland.
           <a href='https://people.inf.ethz.ch/fukudak/' class='url'><span class='cmtt-12'>https://people.inf.ethz.ch/fukudak/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Fuk20a]  <span class='bibsp'>   </span></span><a id='Xf-io-20'></a>K. Fukuda.  Introduction to Optimization.  Research collection, ETH Zurich,
           2020. <a href='http://hdl.handle.net/20.500.11850/426221' class='url'><span class='cmtt-12'>http://hdl.handle.net/20.500.11850/426221</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Fuk20b]  <span class='bibsp'>   </span></span><a id='Xf-pc-20'></a>K. Fukuda. Polyhedral Computation. Research collection, ETH Zurich, 2020.
           <a href='https://doi.org/10.3929/ethz-b-000426218' class='url'><span class='cmtt-12'>https://doi.org/10.3929/ethz-b-000426218</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Ge97]    <span class='bibsp'>   </span></span><a id='Xgo-hbdcg-97'></a>J.E.   Goodman   and   J. O’Rourke   (eds.).      <span class='cmti-12'>Handbook  of  Discrete  and
           </span><span class='cmti-12'>Computational Geometry</span>. CRC Press, 1997.
                                                                                           
                                                                                           
           </p>
           <p class='bibitem'><span class='biblabel'>
 [GJ99]    <span class='bibsp'>   </span></span><a id='Xgj-pm-99'></a>E. Gawrilow    and    M. Joswig.           Polymake,    version    1.3,    1999.
           http://www.math.tu-berlin.de/diskregeom/http://www.math.tu-berlin.de/diskregeom/.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Kal97]   <span class='bibsp'>   </span></span><a id='Xk-lpsasp-97'></a>G. Kalai.                                                                                 Linear
           programming, the simplex algorithm and simple polytopes.  <span class='cmti-12'>Math. Programming</span>,
           79(1-3, Ser. B):217–233, 1997.  Lectures on mathematical programming (ismp97)
           (Lausanne, 1997), <a href='http://www.ma.huji.ac.il/~kalai/papers.html' class='url'><span class='cmtt-12'>http://www.ma.huji.ac.il/~kalai/papers.html</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Kar84]   <span class='bibsp'>   </span></span><a id='Xk-nptal-84'></a>N. Karmarkar.   A new polynomial-time algorithm for linear programming.
           <span class='cmti-12'>Combinatorica</span>, 4:373–395, 1984.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Kha79]   <span class='bibsp'>   </span></span><a id='Xk-palp-79'></a>L.G. Khachiyan.  A polynomial algorithm in linear programming.  <span class='cmti-12'>Dokklady
           </span><span class='cmti-12'>Akademiia Nauk SSSR</span>, 244:1093–1096, 1979.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Kha93]   <span class='bibsp'>   </span></span><a id='Xk-cpvc-93'></a>L.G. Khachiyan.  Complexity of polytope volume computation.  In J. Pach,
           editor,  <span class='cmti-12'>New  Trends  in  Discrete  and  Computational  Geometry</span>,  pages  91–101.
           Springer Verlag, Berlin, 1993.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [LS93]    <span class='bibsp'>   </span></span><a id='Xls-rwcbi-93'></a>L. Lovasz  and  M. Simonovits.   Random  walks  in  a  convex  body  and  an
           improved volume algorithm. <span class='cmti-12'>Random structures &amp; algorithms</span>, 4:359–412, 1993.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Lb99]  <span class='bibsp'>   </span></span><a id='Xl-zvefzo-99'></a>M.E.      Lbbecke.                 zeRone:      Vertex      enumeration      for
           <!-- l. 231 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mn>0</mn> <mo class='MathClass-bin'>-</mo> <mn>1</mn></math>
           polytopes (ver. 1.8.1), 1999. <a href='http://www.math.tu-bs.de/mo/research/zerone.html' class='url'><span class='cmtt-12'>http://www.math.tu-bs.de/mo/research/zerone.html</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Mar97]   <span class='bibsp'>   </span></span><a id='Xm-pdcip-97'></a>A. Marzetta.   <span class='cmti-12'>pd  –  C-implementation  of  the  primal-dual  algoirithm</span>,  1997.
           <a href='http://www.cs.unb.ca/profs/bremner/pd/' class='url'><span class='cmtt-12'>http://www.cs.unb.ca/profs/bremner/pd/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [McM70]  <span class='bibsp'>   </span></span><a id='Xm-mnfcp-70'></a>P. McMullen.    The  maximum  numbers  of  faces  of  a  convex  polytope.
           <span class='cmti-12'>Mathematika</span>, 17:179–184, 1970.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [MRTT53]<span class='bibsp'>   </span></span><a id='Xmrtt-ddm-53'></a>T.S.  Motzkin,  H. Raiffa,  GL.  Thompson,  and  R.M.  Thrall.    The  double
           description method.  In H.W. Kuhn and A.W.Tucker, editors, <span class='cmti-12'>Contributions to
           </span><span class='cmti-12'>Theory of Games, Vol. 2</span>. Princeton University Press, Princeton, RI, 1953.
                                                                                           
                                                                                           
           </p>
           <p class='bibitem'><span class='biblabel'>
 [MS71]   <span class='bibsp'>   </span></span><a id='Xms-cpuc-71'></a>P. McMullen  and  G.C.  Shephard.   <span class='cmti-12'>Convex  polytopes  and  the  upper  bound
           </span><span class='cmti-12'>conjecture</span>. Cambridge University Press, 1971.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Mul94]   <span class='bibsp'>   </span></span><a id='Xm-cg-94'></a>K. Mulmuley.        <span class='cmti-12'>Computational   Geometry,   An   Introduction   Through
           </span><span class='cmti-12'>Randamized Algorithms</span>. Prentice-Hall, 1994.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [O’R]     <span class='bibsp'>   </span></span><a id='Xo-cgafaq'></a>J. O’Rourke. comp.graphics.algorithms FAQ. <a href='http://www.faqs.org/' class='url'><span class='cmtt-12'>http://www.faqs.org/</span></a>.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [OSS95]   <span class='bibsp'>   </span></span><a id='Xoss-eephd-95'></a>Th. Ottmann, S. Schuierer, and S. Soundaralakshmi.  Enumerating extreme
           points in higher dimensions.  In E.W. Mayer and C. Puech, editors, <span class='cmti-12'>STACS 95:
           </span><span class='cmti-12'>12th Annual Symposium on Theoretical Aspects of Computer Science</span>,  Lecture
           Notes in Computer Science 900, pages 562–570. Springer-Verlag, 1995.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Rot92]   <span class='bibsp'>   </span></span><a id='Xr-dchhd-92'></a>G. Rote.  Degenerate convex hulls in high dimensions without extra storage.
           In <span class='cmti-12'>Proc. 8th Annu. ACM Sympos. Comput. Geom.</span>, pages 26–32, 1992.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [RTV97]  <span class='bibsp'>   </span></span><a id='Xrtv-talpip-97'></a>C. Roos,  T. Terlaky,  and  J.-Ph.  Vial.   <span class='cmti-12'>Theory and Algorithms for Linear
           </span><span class='cmti-12'>Optimization: An Interior Point Approach</span>. John Wiley and Sons, 1997.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Sch86]   <span class='bibsp'>   </span></span><a id='Xs-tlip-86'></a>A. Schrijver. <span class='cmti-12'>Theory of linear and integer programming</span>. John Wiley &amp; Sons,
           New York, 1986.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Sei86]    <span class='bibsp'>   </span></span><a id='Xs-chdch-86'></a>R. Seidel.  Constructing higher-dimensional convex hulls at logarithmic cost
           per face. In <span class='cmti-12'>18th STOC</span>, pages 404–413, 1986.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Sei91]    <span class='bibsp'>   </span></span><a id='Xs-eubnf-91'></a>R. Seidel.        Exact   upper   bounds   for   the   number   of   faces   in
           <!-- l. 298 --><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><mi>d</mi></math>-dimensional
           Voronoi diagram.  In P. Gritzmann and B. Sturmfels, editors, <span class='cmti-12'>Applied Geometry
           </span><span class='cmti-12'>and  Discrete  Mathematics  -  The  Victor  Klee  Festschrift</span>,  DIMACS  Series  in
           Discrete Mathematics and Theoretical Computer Science, pages 517–529. Amer.
           Math. Soc., Providence, RI, 1991.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Sey94]   <span class='bibsp'>   </span></span><a id='Xs-nhg-94'></a>P.D. Seymour.  A note on hyperplane generation.  <span class='cmti-12'>J. Combin. Theory, Series
           </span><span class='cmti-12'>B</span>, 61:88–91, 1994.
                                                                                           
                                                                                           
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Yap00]   <span class='bibsp'>   </span></span><a id='Xy-fpaa-00'></a>C.K. Yap.  <span class='cmti-12'>Fundamental problems in algorithmic algebra</span>.  Oxford University
           Press, New York, 2000.
           </p>
           <p class='bibitem'><span class='biblabel'>
 [Zie94]    <span class='bibsp'>   </span></span><a id='Xz-lop-94'></a>G.M. Ziegler.   <span class='cmti-12'>Lectures on polytopes</span>.   Graduate Texts in Mathematics 152.
           Springer-Verlag, 1994.
</p>
           </div>
    
</body> 
</html>